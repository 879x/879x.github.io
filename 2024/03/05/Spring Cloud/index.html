<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring Cloud | 幻季的个人博客</title><meta name="author" content="幻季"><meta name="copyright" content="幻季"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微服务远程调用提供者和消费者 服务提供者：一次业务中，被其他微服务调用的服务。（提供接口给其他微服务） 服务消费者：一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口） 提供者与消费者是相对的 一个服务可以同时是服务提供者和服务消费者  Eureka注册中心Eureka的作用 注册服务信息 拉去服务 user-serice的信息 负载均衡 远程调用   消费者该如何获取服务提供者具体信息">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Cloud">
<meta property="og:url" content="https://879x.github.io/2024/03/05/Spring%20Cloud/">
<meta property="og:site_name" content="幻季的个人博客">
<meta property="og:description" content="微服务远程调用提供者和消费者 服务提供者：一次业务中，被其他微服务调用的服务。（提供接口给其他微服务） 服务消费者：一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口） 提供者与消费者是相对的 一个服务可以同时是服务提供者和服务消费者  Eureka注册中心Eureka的作用 注册服务信息 拉去服务 user-serice的信息 负载均衡 远程调用   消费者该如何获取服务提供者具体信息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://879x.github.io/img/Amashiro.Natsuki.full.2856783.png">
<meta property="article:published_time" content="2024-03-05T07:35:55.000Z">
<meta property="article:modified_time" content="2024-04-02T02:02:55.772Z">
<meta property="article:author" content="幻季">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://879x.github.io/img/Amashiro.Natsuki.full.2856783.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://879x.github.io/2024/03/05/Spring%20Cloud/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring Cloud',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-02 10:02:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background-color.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Amashiro.Natsuki.full.2856783.png')"><nav id="nav"><span id="blog-info"><a href="/" title="幻季的个人博客"><span class="site-name">幻季的个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Cloud</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-05T07:35:55.000Z" title="发表于 2024-03-05 15:35:55">2024-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-02T02:02:55.772Z" title="更新于 2024-04-02 10:02:55">2024-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>141分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Cloud"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h1><h2 id="提供者和消费者"><a href="#提供者和消费者" class="headerlink" title="提供者和消费者"></a>提供者和消费者</h2><ul>
<li>服务提供者：一次业务中，被其他微服务调用的服务。（提供接口给其他微服务）</li>
<li>服务消费者：一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口）</li>
<li>提供者与消费者是相对的</li>
<li>一个服务可以同时是服务提供者和服务消费者</li>
</ul>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><h2 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a><strong>Eureka的作用</strong></h2><ol>
<li>注册服务信息</li>
<li>拉去服务 user-serice的信息</li>
<li>负载均衡</li>
<li>远程调用</li>
</ol>
<ul>
<li>消费者该如何获取服务提供者具体信息？<ul>
<li>服务提供者启动时向eureka注册自己的信息</li>
<li>eureka保存这些信息</li>
<li>消费者根据服务名称向eureka拉去提供者信息</li>
</ul>
</li>
<li>如果有多个服务提供者，消费者该如何选择？<ul>
<li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
</ul>
</li>
<li>消费者如何感知服务提供者健康状态？<ul>
<li>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</li>
<li>eureka会更新记录服务列表信息，心跳不正常会被剔除</li>
<li>消费者就可以拉取到最新的信息</li>
</ul>
</li>
</ul>
<h2 id="Eureka架构"><a href="#Eureka架构" class="headerlink" title="Eureka架构"></a><strong>Eureka架构</strong></h2><p>在Eureka架构中微服务角色有两类：</p>
<ul>
<li>EurekaServer：服务端，注册中心<ul>
<li>记录服务信息</li>
<li>心跳监控</li>
</ul>
</li>
<li>EurekaClient：客户端<ul>
<li>Provider：服务提供者，例如案例中的user-service<ul>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30秒向EurekaServer发送心跳</li>
</ul>
</li>
<li>consumer：服务消费者，例如案例中的order-serice<ul>
<li>根据服务名称从EurekaServer拉去服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a><strong>搭建EurekaServer</strong></h2><p>搭建EurekaServer服务步骤如下：</p>
<ol>
<li>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写启动类，添加@EnableEurekaServer注解</li>
<li>添加application.yml文件，编写下面的配置：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">applicatiopn:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span></span><br><span class="line"><span class="attr">eureka:</span>  </span><br><span class="line">  <span class="attr">client:</span>  </span><br><span class="line">    <span class="attr">service-url:</span>  </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span>    </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注册user-service"><a href="#注册user-service" class="headerlink" title="注册user-service"></a><strong>注册user-service</strong></h2><p>将user-service服务注册都按EurekaServer步骤如下：</p>
<ol>
<li>在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka客户端依赖--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在application.yml文件，编写下面的配置：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>另外，我们可以将user-service多次启动，模拟多实例部署，但为了避免端口冲突，需要修改端口设置：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051436867.png" alt="Pasted image 20231010114855"></p>
<h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a><strong>服务拉取</strong></h2><h3 id="在order-service完成服务拉取"><a href="#在order-service完成服务拉取" class="headerlink" title="在order-service完成服务拉取"></a><strong>在order-service完成服务拉取</strong></h3><p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p>
<ol>
<li>修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure></li>
<li>在order-service项目的启动类OrderApplication中的RestTemplate添加<strong>负载均衡</strong>注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">//负载均衡注解</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><h3 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a><strong>负载均衡流程</strong></h3><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051436799.png" alt="[Pasted image 20231010151331.png]"></p>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a><strong>负载均衡策略</strong></h3><p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一个规则：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051437235.png" alt="[Pasted image 20231010162016.png]"></p>
<p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051437608.png" alt="[Pasted image 20231010162039.png]"></p>
<p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个 新的IRule：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a><strong>饥饿加载</strong></h3><p>Ribbon默认是采用懒加载，及第一次访问时才会创建LoadBalanceClient，请求时间会很长。<br>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment">#指定对userservice这个服务器饥饿加载 </span></span><br></pre></td></tr></table></figure>

<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><h2 id="服务注册到Nacos"><a href="#服务注册到Nacos" class="headerlink" title="服务注册到Nacos"></a><strong>服务注册到Nacos</strong></h2><ol>
<li>在cloud-demo父工程中添加spring-cloud-alibaba的管理依赖:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5。RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>注释掉order-service和user-service中原有的eureka依赖。</li>
<li>添加nacos的客户端依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos客户端依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>修改user-service&amp;order-service中的application.yml文件，注释eureka地址，添加nacos地址：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="服务集群属性"><a href="#服务集群属性" class="headerlink" title="服务集群属性"></a><strong>服务集群属性</strong></h2><ol>
<li>修改application.yml，添加如下内容：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> </span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 配置集群名称，也就是机房位置，例如：HZ，杭州</span></span><br></pre></td></tr></table></figure></li>
<li>在Nacos控制台可以看到集群变化：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051437463.png" alt="[Pasted image 20231011153258.png]"></li>
</ol>
<h2 id="根据集群负载均衡"><a href="#根据集群负载均衡" class="headerlink" title="根据集群负载均衡"></a><strong>根据集群负载均衡</strong></h2><ol>
<li>修改order-service中的application.yml，设置集群为HZ：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> </span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 配置集群名称，也就是机房位置</span></span><br></pre></td></tr></table></figure></li>
<li>然后在order-service中设置负载均衡的Rule为NacosRule，这个规则优先会寻找与自己同集群的服务：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure></li>
<li>注意将user-service的权重都设置为1</li>
</ol>
<h2 id="根据权重负载均衡"><a href="#根据权重负载均衡" class="headerlink" title="根据权重负载均衡"></a><strong>根据权重负载均衡</strong></h2><p>实际部署中会出现这样的场景：</p>
<ul>
<li>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求<br>Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高</li>
</ul>
<ol>
<li>在Nacos控制台可以设置实例的权重值，首先选中实例后面的编辑按钮<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051437761.png" alt="[Pasted image 20231011164637.png]"></li>
<li>将权重设置为0.1，测试可以发现8081被访问到的频率大大降低<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051438566.png" alt="[Pasted image 20231011164858.png]"></li>
<li>权重设置为0则完全不会被访问</li>
</ol>
<h2 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离-namespace"></a><strong>环境隔离-namespace</strong></h2><p>Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051439867.png" alt="[Pasted image 20231012085904.png]"></p>
<ol>
<li>在Nacos控制台可以创建namespace，用来隔离不同环境<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051439516.png" alt="[Pasted image 20231012110758.png]"></li>
<li>然后填写一个新的命名空间信息：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051439884.png" alt="[Pasted image 20231012110848.png]"></li>
<li>保存后会在控制台看到这个命名空间的id：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051439317.png" alt="[Pasted image 20231012111026.png]"></li>
<li>修改order-service的application.yml，添加namespace：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">datasource:</span>  </span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_user?useSSL=false&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span>  </span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>  </span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span>  </span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务地址</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">SH</span> <span class="comment">#上海</span></span><br><span class="line">        <span class="comment"># 命名空间添ID </span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">78523f49-6663-4d0d-b5a4-9d4cada9023e</span></span><br></pre></td></tr></table></figure></li>
<li>重启order-service后，再来查看控制台：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051439310.png" alt="[Pasted image 20231012162256.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051440762.png" alt="[Pasted image 20231012162306.png]"></li>
<li>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051440637.png" alt="[Pasted image 20231012162532.png]"></li>
</ol>
<h2 id="nacos注册中心细节分析"><a href="#nacos注册中心细节分析" class="headerlink" title="nacos注册中心细节分析"></a><strong>nacos注册中心细节分析</strong></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051440039.png" alt="[Pasted image 20231015203656.png]"></p>
<h2 id="临时实例和非临时实例"><a href="#临时实例和非临时实例" class="headerlink" title="临时实例和非临时实例"></a><strong>临时实例和非临时实例</strong></h2><p>服务注册到Nacos时，可以选择注册为临时或非临时实例，通过以下的配置来设置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>  </span><br><span class="line">      <span class="attr">discovery:</span>  </span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 是否为临时实例 true 是临时实例 false 是非临时实例 默认true</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>Nacos与eureka的共同点<ol>
<li>都支持服务注册饥和服务拉取</li>
<li>都支持服务提供者心跳方式组偶健康检测</li>
</ol>
</li>
<li>Nacos与Eureka的区别<ol>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被踢出</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式：Eureka采用AP方式</li>
</ol>
</li>
</ol>
<h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><h2 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h2><ol>
<li><p>在Nacos中添加配置信息：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051440933.png" alt="[Pasted image 20231015210554.png]"></p>
</li>
<li><p>在弹出表单中填写配置信息：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051441746.png" alt="[Pasted image 20231015211126.png]"></p>
</li>
</ol>
<p>配置获取的步骤如下：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051441465.png" alt="[Pasted image 20231015211414.png]"></p>
<ol>
<li>引入Nacos的配置管理客户端依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos配置管理依赖 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在userservice中的resource目录添加一个bootstrap.yml文件，这个文件时引导文件，优先级高于application.yml：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span>  </span><br><span class="line">  <span class="attr">profiles:</span>  </span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境，这里是dev  </span></span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址  </span></span><br><span class="line">      <span class="attr">config:</span>  </span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure>
我们在user-service中将pattern.dateformat这个属性注入到UserController中做测试：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> UserService userService;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注入nacos中的配置属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String dateformat;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置自动刷新"><a href="#配置自动刷新" class="headerlink" title="配置自动刷新"></a>配置自动刷新<br></h2><p>Nacos中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现：</p>
<ul>
<li>方式一：在@Value注入的变量所在类上添加注解@RefreshScope<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br></pre></td></tr></table></figure></li>
<li>方式二：使用@ConfigurationProperties注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String dateformat;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享<br></h2><p>微服务启动时会从nacos读取多个配置文件：</p>
<ul>
<li>[spring.application.name]-[spring.profiles.active].yaml，例如：userseevice-dev.yaml</li>
<li>[spring.application.name].yaml，例如：userservice.yaml<br>无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件<br>![[Pasted image 20231016100557.png]]</li>
</ul>
<p>多种配置的优先级：</p>
<ul>
<li>服务名-profile.yaml &gt; 服务名称.yaml &gt; 本地配置</li>
</ul>
<h2 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建<br></h2><p>集群搭建步骤：</p>
<ol>
<li>搭建MySQL集群并初始化数据库表</li>
<li>下载解压nacos</li>
<li>修改集群配置(节点信息)、数据库配置</li>
<li>分别启动多个nacos节点</li>
<li>nginx反向代理</li>
</ol>
<h1 id="http客户端Feign"><a href="#http客户端Feign" class="headerlink" title="http客户端Feign"></a>http客户端Feign<br></h1><h2 id="Feign替换RestTemplate"><a href="#Feign替换RestTemplate" class="headerlink" title="Feign替换RestTemplate"></a>Feign替换RestTemplate</h2><h3 id="RestTemplate方式调用存在的问题"><a href="#RestTemplate方式调用存在的问题" class="headerlink" title="RestTemplate方式调用存在的问题"></a><strong>RestTemplate方式调用存在的问题</strong></h3><p>先来看看我们以前利用RestTemplate发起远程调用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br></pre></td></tr></table></figure>
<p>存在下面的问题：</p>
<ul>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ul>
<h3 id="Feign的介绍"><a href="#Feign的介绍" class="headerlink" title="Feign的介绍"></a><strong>Feign的介绍</strong></h3><p>Feign是一个声明式的http客户端，官方地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a><br>其作用就是帮助我们优雅的实现http请求的发送，解决上面的问题。</p>
<h2 id="定义和使用Feign客户端"><a href="#定义和使用Feign客户端" class="headerlink" title="定义和使用Feign客户端"></a><strong>定义和使用Feign客户端</strong></h2><p>使用Feign的步骤如下：</p>
<ol>
<li>引入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>在order-service的启动类添加注解开启Feign的功能：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启Feign</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span>  </span><br><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写Feign客户端：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">	user <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
主要是基于SPringMVC的注解来声明远程调用的信息，比如：</li>
</ol>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li>请求路径：&#x2F;user&#x2F;{id}</li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<ol start="4">
<li>用Feign客户端代替RestTemplate<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> UserClient userClient;  </span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;  </span><br><span class="line">    <span class="comment">// 1.查询订单  </span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);  </span><br><span class="line">    <span class="comment">//2.用Feign远程调用  </span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findById(order.getUserId());  </span><br><span class="line">    <span class="comment">//3.封装user到order</span></span><br><span class="line">    order.setUser(user);  </span><br><span class="line">    <span class="comment">// 4.返回  </span></span><br><span class="line">    <span class="keyword">return</span> order;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="自定义Feign的配置"><a href="#自定义Feign的配置" class="headerlink" title="自定义Feign的配置"></a>自定义Feign的配置<br></h2><p>Fegin运行自定义配置来覆盖默认配置，可以修改的配置如下：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051441520.png" alt="[Pasted image 20231016110655.png]"><br>一般我们需要配置的就是日志级别。</p>
<p>配置Feign日志有两种方式：</p>
<p>方式一：配置文件方式</p>
<ol>
<li>全局生效：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#日志级别</span></span><br></pre></td></tr></table></figure></li>
<li>局部生效：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment">#这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#日志级别</span></span><br></pre></td></tr></table></figure>
配置Feign日志的方式二：java代码方式，需要先声明一个Bean：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignClientConfiguration</span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Logger.Level.feignLogLevel()&#123;</span><br><span class="line">		<span class="keyword">return</span> Logger.Level.BASIC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>而后如果是全局配置，则把它放到@EnableFeignClients这个注解中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure></li>
<li>如果是局部配置，则把它放到@FeignClient这个注解中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;,configuration = FeignClientConfiguration.class)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化<br></h2><p>Feign底层的客户端实现：</p>
<ul>
<li>URLConnection：默认实现，不支持连接池</li>
<li>Apache HttpClient：支持连接池</li>
<li>OKHttp：支持连接池<br>因此优化Feign的性能主要包括：</li>
</ul>
<ol>
<li>使用连接池代替默认的URLConnection</li>
<li>日志级别，最好用basic或none</li>
</ol>
<h3 id="Feign的性能优化-连接池配置"><a href="#Feign的性能优化-连接池配置" class="headerlink" title="Feign的性能优化-连接池配置"></a><strong>Feign的性能优化-连接池配置</strong><br></h3><p>Fegin添加HttpClient的支持：<br>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>       </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置连接池:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment">#default全局配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment">#日志级别，BASIC就是基本的请求和相应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="string">ture</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment">#最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>
<h2 id="Fegin的最佳实践"><a href="#Fegin的最佳实践" class="headerlink" title="Fegin的最佳实践"></a>Fegin的最佳实践<br></h2><p>方式一（继承）：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准<br>缺点：</p>
<ul>
<li>服务紧耦合</li>
<li>父接口参数列表中的映射不会被继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserAPI</span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">	User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> <span class="keyword">extends</span> <span class="title class_">UserAPI</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">USerAPI</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
方式二（抽取）：将FeignClient抽取为独立模块，并把接口有关的POJO，默认的Feign配置都放到这个模块中，提供给所有消费者使用<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051441841.png" alt="[Pasted image 20231016143704.png]"></li>
</ul>
<h2 id="抽取FeignClient"><a href="#抽取FeignClient" class="headerlink" title="抽取FeignClient"></a>抽取FeignClient<br></h2><p>实现最佳实践方式二的步骤如下：</p>
<ol>
<li>首先创建一个module，命名为feign-api，然后引入feign的starter依赖</li>
<li>将order-service中编写的UserClient、User、DefaultFeignCOnfiguration都复制到feign-api项目中</li>
<li>在order-service中引入feign-api的依赖</li>
<li>修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包</li>
<li>重启测试<br>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种方式解决：<br>方式一：指定FeignClient所在包<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcase.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure>
方式二：指定FeignClient字节码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clicents = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="统一网关Gateway"><a href="#统一网关Gateway" class="headerlink" title="统一网关Gateway"></a>统一网关Gateway<br></h1><h2 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关<br></h2><p>网关功能：</p>
<ul>
<li>身份认证和权限校验</li>
<li>服务路由、负载均衡</li>
<li>请求限流</li>
</ul>
<h2 id="网关的技术实现"><a href="#网关的技术实现" class="headerlink" title="网关的技术实现"></a>网关的技术实现<br></h2><p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul<br>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</li>
</ul>
<h2 id="搭建网关服务"><a href="#搭建网关服务" class="headerlink" title="搭建网关服务"></a>搭建网关服务<br></h2><p>搭建网关服务的步骤：</p>
<ol>
<li>创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nacos服务发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写路由配置及nacos地址<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">		  <span class="comment"># uri http://127.0.0.1:8081 #路由的目标地址 http就是固定地址</span></span><br><span class="line">		  <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">		  <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">		    <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由断言工厂Route-Predicate-Factoy"><a href="#路由断言工厂Route-Predicate-Factoy" class="headerlink" title="路由断言工厂Route Predicate Factoy"></a>路由断言工厂Route Predicate Factoy<br></h2><p>网关路由可以配置的内容包括：</p>
<ul>
<li><p>路由id：路由唯一标识</p>
</li>
<li><p>uri：路由目的地。支持lb和http两种</p>
</li>
<li><p>predicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地</p>
</li>
<li><p>filters：路由过滤器，处理请求或响应</p>
</li>
<li><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p>
</li>
<li><p>例如Path&#x3D;&#x2F;user&#x2F;** 是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的</p>
</li>
<li><p>像这样的断言工厂在SpringCloudGateway还有十几个</p>
</li>
</ul>
<p>Spring提供了11种基本的Predicate工厂：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442016.png" alt="[Pasted image 20231016164528.png]"></p>
<h2 id="路由过滤器-GatewayFilter"><a href="#路由过滤器-GatewayFilter" class="headerlink" title="路由过滤器 GatewayFilter"></a>路由过滤器 GatewayFilter<br></h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进行网关的请求和微服务返回的响应做处理：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442031.png" alt="[Pasted image 20231016173504.png]"></p>
<h2 id="过滤器工厂-GatewayFilterFactory"><a href="#过滤器工厂-GatewayFilterFactory" class="headerlink" title="过滤器工厂 GatewayFilterFactory"></a>过滤器工厂 GatewayFilterFactory<br></h2><p>Spring提供了31种不同的路由过滤器工厂，例如：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442696.png" alt="[Pasted image 20231016173759.png]"></p>
<h2 id="案例：给所有进入userservice的请求添加一个请求头"><a href="#案例：给所有进入userservice的请求添加一个请求头" class="headerlink" title="案例：给所有进入userservice的请求添加一个请求头"></a>案例：给所有进入userservice的请求添加一个请求头<br></h2><p>给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!<br>实现方式：在gateway中修改application.yml文件，给userservice的路由添加过滤器：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring：</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb//userservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth=itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment">#添加请求头</span></span><br></pre></td></tr></table></figure>
<h3 id="默认过滤器"><a href="#默认过滤器" class="headerlink" title="默认过滤器"></a><strong>默认过滤器</strong><br></h3><p>如果要对所有的路由都生效，则可以将过滤工厂写到Default下。格式如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span>  </span><br><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos地址  </span></span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由标识，必须唯一  </span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址  </span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断请求是否符合规则  </span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路径断言，判断路径是否以/user开头，如果是则符合  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span>  </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderservice</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">	  <span class="attr">default-filters:</span> <span class="comment"># 默认过滤器，会对所有的路由请求都生效</span></span><br><span class="line">	    </span><br></pre></td></tr></table></figure>
<h2 id="全局过滤器-GlobalFilter"><a href="#全局过滤器-GlobalFilter" class="headerlink" title="全局过滤器 GlobalFilter"></a>全局过滤器 GlobalFilter<br></h2><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。<br>区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。<br>定义方式是实现GlobalFilter接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span>&#123;</span><br><span class="line">	Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤一：自定义过滤器<br>自定义类，实现GlobalFilter接口，添加@Order注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;  </span><br><span class="line">        <span class="comment">//1.获取请求参数  </span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();  </span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();  </span><br><span class="line">        <span class="comment">//2.获取参数中的authorization 参数  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);  </span><br><span class="line">        <span class="comment">//3.判断参数值是否等于admin  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(auth))&#123;  </span><br><span class="line">            <span class="comment">//4.是，放行  </span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//5.否，拦截  </span></span><br><span class="line">        <span class="comment">//5.1.设置状态码  </span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);  </span><br><span class="line">        <span class="comment">//5.2.拦截请求  </span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序<br></h2><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter<br>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增</li>
<li>当过滤器的order值一样时，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行<br>可以参考下面几个类的源码来查看：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442403.png" alt="[Pasted image 20231016205931.png]"></li>
</ul>
<h2 id="跨域问题处理"><a href="#跨域问题处理" class="headerlink" title="跨域问题处理"></a>跨域问题处理<br></h2><p>跨域：域名不一致就是跨域，主要包括：</p>
<ul>
<li>域名不同：<a target="_blank" rel="noopener" href="http://www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com/">www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com</a></li>
<li>域名相同，端口不同：loaclhost:8080和loaclhost8081<br>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题<br>解决方案：CORS</li>
</ul>
<p>网关处理跨域采用的同样是CORS方案，并且只需要简单配置即可实现：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>   </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos地址  </span></span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">globalcors:</span>  </span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截问题  </span></span><br><span class="line">        <span class="attr">corsConfigurations:</span>  </span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span>  </span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment">#允许那些网站的跨域请求  </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span>  </span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span>  </span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment">#允许的跨域ajax的请求方式  </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span>  </span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span>  </span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span>  </span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span>  </span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span>  </span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息 </span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带cookie  </span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>
<h1 id="初始Docker"><a href="#初始Docker" class="headerlink" title="初始Docker"></a>初始Docker<br></h1><h2 id="项目部署的问题"><a href="#项目部署的问题" class="headerlink" title="项目部署的问题"></a>项目部署的问题<br></h2><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442831.png" alt="[Pasted image 20231017074555.png]"></li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker<br></h2><p>Docker如何解决依赖的兼容问题的？</p>
<ul>
<li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li>
<li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰<br>不同环境的操作系统不同，Docker如何解决？我们先来了解下操作系统架构<br>![[Pasted image 20231017075912.png]]<br>内核与硬件交互，提供操作硬件的指令<br>系统应用封装内核指令为函数，便于程序员调用<br>用户程序基于系统函数库实现功能<br>Ubuntu和CentOS都是基于Linux内核，只是系统应用不同，提供的函数库有差异</li>
</ul>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核来运行<br>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</li>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong><br>Docker如何解决开发、测试、生存环境有差异的问题</li>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以再任意Linux操作系统上运行<br>Docker是一个快速交付应用、运行应用的技术：</li>
</ul>
<ol>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ol>
<h2 id="Docker与虚拟机"><a href="#Docker与虚拟机" class="headerlink" title="Docker与虚拟机"></a>Docker与虚拟机<br></h2><p>虚拟机(virtual machine)是在操作系统重模拟硬件设备，然后运行另一个操作系统，比如在Windows系统里面运行Ubuntu系统，这样就可以运行任意的Ubuntu应用了<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442453.png" alt="[Pasted image 20231017081809.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051442349.png" alt="[Pasted image 20231017081828.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051443075.png" alt="[Pasted image 20231017081857.png]"><br>Docker和虚拟机的差异：</p>
<ul>
<li>docker是一个系统进程；虚拟机是在操作系统重的操作系统</li>
<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>
</ul>
<h2 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器<br></h2><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像<br><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器做隔离，对外不可见</p>
<h2 id="Docker和DockerHub"><a href="#Docker和DockerHub" class="headerlink" title="Docker和DockerHub"></a>Docker和DockerHub<br></h2><ul>
<li>DockerHub：DockerHub是一个Docker镜像的托管平台。这样的平台称为Docker Registry</li>
<li>国内也有类似于DockerHub的公开服务，比如网易云镜像服务、阿里云镜像库等</li>
</ul>
<h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构<br></h2><p>Docker是一个CS架构的程序，有两部分组成：</p>
<ul>
<li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li>
<li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以再本地或远程向服务端发送指令<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051444876.png" alt="[Pasted image 20231017083507.png]"></li>
</ul>
<h1 id="Docker基本操作"><a href="#Docker基本操作" class="headerlink" title="Docker基本操作"></a>Docker基本操作<br></h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令<br></h2><ul>
<li>镜像名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051443465.png" alt="[Pasted image 20231017100702.png]"></li>
</ul>
<h2 id="镜像操作命令"><a href="#镜像操作命令" class="headerlink" title="镜像操作命令"></a>镜像操作命令<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051443617.png" alt="[Pasted image 20231017100959.png]"></p>
<h3 id="案例：从DockerHub中拉取一个nginx镜像并查看"><a href="#案例：从DockerHub中拉取一个nginx镜像并查看" class="headerlink" title="案例：从DockerHub中拉取一个nginx镜像并查看"></a><strong>案例：从DockerHub中拉取一个nginx镜像并查看</strong><br></h3><ol>
<li>首先去镜像仓库搜索nginx镜像，比如DockerHub：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051444146.png" alt="[Pasted image 20231017101811.png]"></li>
<li>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051444344.png" alt="[Pasted image 20231017101922.png]"></li>
<li>通过命令：docker images 查看拉取到的镜像<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051444582.png" alt="[Pasted image 20231017102010.png]"></li>
</ol>
<h3 id="案例：利用docker-save将nginx镜像导出磁盘，然后在通过load加载回来"><a href="#案例：利用docker-save将nginx镜像导出磁盘，然后在通过load加载回来" class="headerlink" title="案例：利用docker save将nginx镜像导出磁盘，然后在通过load加载回来"></a><strong>案例：利用docker save将nginx镜像导出磁盘，然后在通过load加载回来</strong><br></h3><p>步骤一：利用docker xx –help命令查看docker save和docker load的语法</p>
<p>步骤二：使用docker tag 创建新镜像mynginx1.0</p>
<p>步骤三：使用docker save导出镜像到磁盘</p>
<h3 id="镜像操作有哪些？"><a href="#镜像操作有哪些？" class="headerlink" title="镜像操作有哪些？"></a><strong>镜像操作有哪些？</strong><br></h3><ul>
<li>docker images 查看镜像</li>
<li>docker rmi 删除</li>
<li>docker pull 拉取</li>
<li>docker push 推送</li>
<li>docker save 保存</li>
<li>docker load 加载</li>
</ul>
<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051445073.png" alt="[Pasted image 20231017105030.png]"></p>
<h3 id="案例：创建运行一个nginx容器"><a href="#案例：创建运行一个nginx容器" class="headerlink" title="案例：创建运行一个nginx容器"></a><strong>案例：创建运行一个nginx容器</strong><br></h3><p>步骤一：去docker hub查看Nginx的容器运行命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker run：创建并运行一个容器</li>
<li>--name：给容器起一个名字，比如叫做mn</li>
<li>-p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx<br>查看容器日志的命令：</li>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志<br>查看容器状态：</li>
<li>docker ps</li>
</ul>
<h3 id="案例：进入Nginx容器，修改HTML文件内容，添加“Hello”"><a href="#案例：进入Nginx容器，修改HTML文件内容，添加“Hello”" class="headerlink" title="案例：进入Nginx容器，修改HTML文件内容，添加“Hello”"></a><strong>案例：进入Nginx容器，修改HTML文件内容，添加“Hello”</strong><br></h3><p>步骤一：进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker exec：进入容器内部，执行一个命令</li>
<li>-it：给当前进入的容器创建一个标椎输入、输出终端，允许我们与容器交互</li>
<li>mn：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷<br></h2><p>容器与数据耦合的问题<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051447377.png" alt="[Pasted image 20231017113857.png]"></p>
<p><strong>数据卷（volume）</strong>：是一个虚拟目录，指向宿主机文件系统的某个目录<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051447246.png" alt="[Pasted image 20231017114419.png]"></p>
<h2 id="操作数据卷"><a href="#操作数据卷" class="headerlink" title="操作数据卷"></a>操作数据卷<br></h2><p>数据卷操作的基本语法如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume[COMMAND]</span><br></pre></td></tr></table></figure>
<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create  创建一个volume</li>
<li>inspect  显示一个或多个volume的信息</li>
<li>ls  列出所有的volume</li>
<li>prune  删除未使用的volume</li>
<li>rm  删除一个或多个指定的volume</li>
</ul>
<h3 id="创建一个数据卷，并查看数据卷在宿主机的目录位置"><a href="#创建一个数据卷，并查看数据卷在宿主机的目录位置" class="headerlink" title="创建一个数据卷，并查看数据卷在宿主机的目录位置"></a><strong>创建一个数据卷，并查看数据卷在宿主机的目录位置</strong><br></h3><ol>
<li>创建数据卷<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure></li>
<li>查看所有数据<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure></li>
<li>查看数据卷详细信息卷<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷<br></h2><p>我们在创建容器时，可以通过-v参数来挂载一个数据卷到某个容器目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run: 就是创建并运行容器</span><br><span class="line">-- name mn: 给容器起个名字叫mn</span><br><span class="line">-v html:/root/html: 把html数据卷挂载到容器内的/root/html这个目录中</span><br><span class="line">-p 8080:80: 把宿主机的8080端口映射到容器内的80端口</span><br><span class="line">nginx: 镜像名称</span><br></pre></td></tr></table></figure>
<h3 id="创建一个nginx容器，修改容器内的html目录内的index-html内容"><a href="#创建一个nginx容器，修改容器内的html目录内的index-html内容" class="headerlink" title="创建一个nginx容器，修改容器内的html目录内的index.html内容"></a><strong>创建一个nginx容器，修改容器内的html目录内的index.html内容</strong><br></h3><p>需求说明：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;user&#x2F;share&#x2F;nginx&#x2F;html，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。<br>提示：运行容器时使用-v参数挂载数据卷<br>步骤：</p>
<ol>
<li>创建容器并挂载数据卷到容器内的HTML目录<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure></li>
<li>进入html数据卷所在位置，并修改HTML内容<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入该目录</span></span><br><span class="line">cd /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建并运行一个MySQL容器，将宿主机目录直接挂载到容器"><a href="#创建并运行一个MySQL容器，将宿主机目录直接挂载到容器" class="headerlink" title="创建并运行一个MySQL容器，将宿主机目录直接挂载到容器"></a><strong>创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</strong><br></h3><p>提示：目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v[宿主机目录]:[容器内目录]</li>
<li>-v[宿主机文件]:[容器内文件]<br>实现思路如下：</li>
</ul>
<ol>
<li>在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</li>
<li>创建目录&#x2F;tmp&#x2F;myql&#x2F;data</li>
<li>创建目录&#x2F;tmp&#x2F;myql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tpm&#x2F;myql&#x2F;conf</li>
<li>去DockerHub查阅资料，创建并运行MySQL容器，要求：<ol>
<li>挂载&#x2F;tmp&#x2F;myql&#x2F;data到mysql容器内数据存储目录</li>
<li>挂载&#x2F;tmp&#x2F;myql&#x2F;conf&#x2F;hmy.cnf到msql容器的配置文件</li>
<li>设置MySQL密码</li>
</ol>
</li>
</ol>
<h3 id="数据卷挂载的方式对比"><a href="#数据卷挂载的方式对比" class="headerlink" title="数据卷挂载的方式对比"></a><strong>数据卷挂载的方式对比</strong><br></h3><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051448783.png" alt="[Pasted image 20231017160552.png]"></p>
<h1 id="Dcokerfile自定义镜像"><a href="#Dcokerfile自定义镜像" class="headerlink" title="Dcokerfile自定义镜像"></a>Dcokerfile自定义镜像<br></h1><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构<br></h2><ul>
<li>镜像是指将应用程序及其需要的系统函数库、环境、配置、依赖打包而成</li>
<li>入口（Entrypoint）<ul>
<li>镜像运行入口，一般是程序启动的脚本和参数</li>
</ul>
</li>
<li>层（Layer）<ul>
<li>在BaseImage基础上添加安装包、依赖、配置等，每次操作都形成新的一层</li>
</ul>
</li>
<li>基础镜像（BaseImage）<ul>
<li>应用依赖的系统函数库、环境、配置、文件等</li>
</ul>
</li>
</ul>
<h2 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile<br></h2><p>Docekrfile就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>,用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051448521.png" alt="[Pasted image 20231017162228.png]"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例<br></h3><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051448955.png" alt="[Pasted image 20231017163840.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051448590.png" alt="[Pasted image 20231017163859.png]"></p>
<h1 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose<br></h1><h2 id="什么是DockerCompose"><a href="#什么是DockerCompose" class="headerlink" title="什么是DockerCompose"></a>什么是DockerCompose<br></h2><ul>
<li>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</li>
<li>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">8090:</span> <span class="number">8090</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Docker镜像仓库"><a href="#Docker镜像仓库" class="headerlink" title="Docker镜像仓库"></a>Docker镜像仓库<br></h1><h2 id="常见镜像仓库服务"><a href="#常见镜像仓库服务" class="headerlink" title="常见镜像仓库服务"></a>常见镜像仓库服务<br></h2><p>镜像仓库（Docker Registry）有公共的和私有的两种形式：</p>
<ul>
<li>公共仓库：例如Docker官方的<a href="hub.docker.com">Docker Hub</a>，国内也有一些云服务商提供类似于Docker Hub的公开服务，比如网易云镜像服务、DaoCloud镜像服务、阿里云镜像服务等</li>
<li>除了使用公开仓库外，用户还可以再本地搭建私有Docker Registry。企业自己的镜像最好是采用私有Docker Registry来实现</li>
</ul>
<h2 id="在私有镜像仓库推送或拉取镜像"><a href="#在私有镜像仓库推送或拉取镜像" class="headerlink" title="在私有镜像仓库推送或拉取镜像"></a>在私有镜像仓库推送或拉取镜像<br></h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<ol>
<li>重新tag本地镜像，名称前缀为私有仓库的地址：192.168.140.130:8080&#x2F;<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.140.130:8080/nginx:1.0</span><br></pre></td></tr></table></figure></li>
<li>推送镜像<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.140.130:8080/nginx:1.0</span><br></pre></td></tr></table></figure></li>
<li>拉取镜像<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.140.130:8080/nginx:1.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ<br></h1><h2 id="同步通讯和异步通讯"><a href="#同步通讯和异步通讯" class="headerlink" title="同步通讯和异步通讯"></a>同步通讯和异步通讯<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051448948.png" alt="[Pasted image 20231018092107.png]"></p>
<h2 id="同步调用的问题"><a href="#同步调用的问题" class="headerlink" title="同步调用的问题"></a>同步调用的问题<br></h2><p>微服务间基于Feign的调用就属于同步方式，存在一些问题<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051449927.png" alt="[Pasted image 20231018092747.png]"></p>
<ol>
<li>耦合度高<ul>
<li>每次加入新的需求，都要修改原来的代码</li>
</ul>
</li>
<li>性能下降<ul>
<li>调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和</li>
</ul>
</li>
<li>资源浪费<ul>
<li>调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li>
</ul>
</li>
<li>级联失败<ul>
<li>如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障<br> 同步调用的优点：</li>
</ul>
</li>
</ol>
<ul>
<li>时效性较强，可以立即得到结果<br>同步调用的问题：</li>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
<h2 id="异步调用方案"><a href="#异步调用方案" class="headerlink" title="异步调用方案"></a>异步调用方案<br></h2><p>异步调用常见实现就是事件驱动模式<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051450859.png" alt="[Pasted image 20231018094900.png]"></p>
<h2 id="事件驱动优势"><a href="#事件驱动优势" class="headerlink" title="事件驱动优势"></a>事件驱动优势<br></h2><p>优势一：服务解耦<br>优势二：性能提升，吞吐量提高<br>优势三：服务没有强依赖，不担心级联失败问题<br>优势四：流量削峰</p>
<h2 id="异步通信的缺点"><a href="#异步通信的缺点" class="headerlink" title="异步通信的缺点"></a>异步通信的缺点<br></h2><p>缺点一：依赖于Broker的可靠性、安全性、吞吐能力<br>缺点二：架构复杂了，业务没有明显的流程线，不好追踪管理</p>
<h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ<br></h2><p>MQ（MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051450945.png" alt="[Pasted image 20231018100927.png]"></p>
<h1 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门<br></h1><h2 id="RabbitMQ概述"><a href="#RabbitMQ概述" class="headerlink" title="RabbitMQ概述"></a>RabbitMQ概述<br></h2><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：(<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>)</p>
<p>RabbitMQ的结构和概念<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051451181.png" alt="[Pasted image 20231018105546.png]"><br>概念：</p>
<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路由消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组</li>
</ul>
<h2 id="常见消息模型"><a href="#常见消息模型" class="headerlink" title="常见消息模型"></a>常见消息模型<br></h2><p>MQ的官方文档中给出了5个MQ的Demo示例，对应了几种不同的用法：</p>
<ul>
<li>基本消息队列（BasicQueue）</li>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051451961.png" alt="[Pasted image 20231018110645.png]"></li>
<li>工作消息队列（WorkQueue）</li>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051451451.png" alt="[Pasted image 20231018110658.png]"></li>
<li>发布订阅（Publish、Subscribe），有根据交换机类型不同分为三种：<ul>
<li>Fanout Exchange：广播</li>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051451309.png" alt="[Pasted image 20231018110714.png]"></li>
<li>Direct Exchange：路由</li>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051452496.png" alt="[Pasted image 20231018110726.png]"></li>
<li>Topic Exchange：主题</li>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051452591.png" alt="[Pasted image 20231018110734.png]"></li>
</ul>
</li>
</ul>
<h2 id="HelloWorld案例"><a href="#HelloWorld案例" class="headerlink" title="HelloWorld案例"></a>HelloWorld案例<br></h2><p>官方的HellowWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到对类queue</li>
<li>queue：消息队列里，负责接收并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051452729.png" alt="[Pasted image 20231018111117.png]"></li>
</ul>
<h2 id="完成官方Demo中的hello-world案例"><a href="#完成官方Demo中的hello-world案例" class="headerlink" title="完成官方Demo中的hello world案例"></a>完成官方Demo中的hello world案例<br></h2><p>实现步骤：</p>
<ul>
<li>导入课前资料中的demo工程</li>
<li>运行publisher服务中的测试类PublisherTest中的测试方法testSendMessage()</li>
<li>查看RabbitMQ控制台的消息</li>
<li>启动consumer服务，查看是否能接收消息<br>基本消息队列的消息发送流程：</li>
</ul>
<ol>
<li>建立connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>利用channel向队列发送消息<br>基本消息队列的消息接收流程：</li>
<li>建立connection</li>
<li>创建channel</li>
<li>利用channel声明队列</li>
<li>定义consumer的消费行为handleDelivery()</li>
<li>利用channel将消费者与队列绑定</li>
</ol>
<h1 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP<br></h1><h2 id="什么SpringAMQP"><a href="#什么SpringAMQP" class="headerlink" title="什么SpringAMQP"></a>什么SpringAMQP<br></h2><p>SpringAmqp的官方地址：(<a target="_blank" rel="noopener" href="https://spring.io/pojects/spring-amqp">https://spring.io/pojects/spring-amqp</a>)<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051453603.png" alt="[Pasted image 20231018114602.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051453359.png" alt="[Pasted image 20231018114610.png]"></p>
<h2 id="利用SpringAMQP实现HelloWorld中的基础消息队列功能"><a href="#利用SpringAMQP实现HelloWorld中的基础消息队列功能" class="headerlink" title="利用SpringAMQP实现HelloWorld中的基础消息队列功能"></a>利用SpringAMQP实现HelloWorld中的基础消息队列功能<br></h2><p>流程如下：</p>
<ol>
<li>在父工程中引入spring-amqp的依赖</li>
<li>在publisher服务中利用RabbitTemplate发送消息到simple.queue这个队列</li>
<li>在consumer服务中编写消费逻辑，绑定simple.queue这个队列<br>步骤1：引入AMQP依赖<br>因为publisher和consumer服务都需要amqp依赖，因此这里吧依赖直接放到父工程mq-demo中：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AMQP依赖，包含RabbitMQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
步骤2：在publisher中编写测试方法，向simple.queue发送消息</li>
<li>在publisher服务中编写application.yml，添加mq连接信息：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.130</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">huanji</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure></li>
<li>在publisher服务中新建一个测试类，编写测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello,spring amqp&quot;</span>;  </span><br><span class="line">        rabbitTemplate.convertAndSend(queueName,message);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤3：在consumer中编写消费逻辑，监听simple.queue</li>
<li>在consumer服务中编写application.yml，添加mq连接信息：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">rabbitmq:</span>  </span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.130</span> <span class="comment"># 主机名  </span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口  </span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机  </span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">huanji</span> <span class="comment"># 用户名  </span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure></li>
<li>在consumer服务中新建一个类，编写消费逻辑：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;  </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息 : 【&quot;</span>+ msg +<span class="string">&quot;】&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Work-Queue工作队列"><a href="#Work-Queue工作队列" class="headerlink" title="Work Queue工作队列"></a>Work Queue工作队列<br></h2><p>Work queue，工作队列，可以提高消息处理速度，避免队列消息堆积</p>
<h2 id="模拟WorkQueue，实现一个队列绑定多个消费者"><a href="#模拟WorkQueue，实现一个队列绑定多个消费者" class="headerlink" title="模拟WorkQueue，实现一个队列绑定多个消费者"></a>模拟WorkQueue，实现一个队列绑定多个消费者<br></h2><p>基本思路如下：</p>
<ol>
<li>在publisher服务中定义测试方法，每秒产生50条消息，发送到simple.queue</li>
<li>在consumer服务中定义两个消息监听者，都监听simplq.queue队列</li>
<li>消费者1每秒处理50条消息，消费者2每秒处理10条信息</li>
</ol>
<h2 id="消费预取限制"><a href="#消费预取限制" class="headerlink" title="消费预取限制"></a>消费预取限制<br></h2><p>修改application.yml文件，设置preFetch这个值，可以控制预取消息的上限：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">rabbitmq:</span>  </span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.130</span> <span class="comment"># 主机名  </span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口  </span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机  </span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">huanji</span> <span class="comment"># 用户名  </span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">listenter:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="string">prefetch:1</span> <span class="comment">#每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>
<h2 id="发布（Publish）、订阅（Subscribe）"><a href="#发布（Publish）、订阅（Subscribe）" class="headerlink" title="发布（Publish）、订阅（Subscribe）"></a>发布（Publish）、订阅（Subscribe）<br></h2><p>发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）<br>常见exchange类型包括：</p>
<ul>
<li>Fanout：广播</li>
<li>Direct：路由</li>
<li>Topic：话题<br>![[Pasted image 20231019074657.png]]<br>注意：exchange负责消息路由，而不是存储，路由失败则消息丢失</li>
</ul>
<h2 id="发布订阅-Fanout-Exchange"><a href="#发布订阅-Fanout-Exchange" class="headerlink" title="发布订阅-Fanout Exchange"></a>发布订阅-Fanout Exchange<br></h2><p>Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的queue<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051454618.png" alt="[Pasted image 20231019075136.png]"></p>
<h2 id="利用SpringAMQP演示FanoutExchange的使用"><a href="#利用SpringAMQP演示FanoutExchange的使用" class="headerlink" title="利用SpringAMQP演示FanoutExchange的使用"></a>利用SpringAMQP演示FanoutExchange的使用<br></h2><p>实现思路如下：</p>
<ol>
<li>在consumer服务中，利用代码声明队列、交换机，并将两者绑定</li>
<li>在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</li>
<li>在publisher中编写测试方法，向huanji.fanout发送消息<br>步骤1：在consumer服务声明Exchange、Queue、Binding<br>SpringAMQP提供了声明交换机、队列、绑定关系的API，例如：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051454775.png" alt="[Pasted image 20231019075950.png]"><br>在consumer服务常见一个类，添加@Configuration注解，并声明FanoutExchange、Queue和绑定关系对象Binding，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// huanji.fanout  </span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;huanji.fanout&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//fanout.queue1  </span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//绑定队列1到交换机  </span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//fanout.queue2  </span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//绑定队列2到交换机  </span></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤2：在consumer服务声明两个消费者<br><br>在consumer服务的SpringRabbitListener类中，添加两个方法，分别监听fanout.queue1和fanout.queue2:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.err.println(<span class="string">&quot;消费者接收到fanout.queue1的消息 : 【&quot;</span>+ msg +<span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.err.println(<span class="string">&quot;消费者接收到fanout.queue2的消息 : 【&quot;</span>+ msg +<span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤3：在publisher服务发送消息到FanoutExchange<br>在publisher服务的SpringAmqpTest类中添加测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendFanoutExchange</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// 交换机名称  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;huanji.fanout&quot;</span>;  </span><br><span class="line">    <span class="comment">// 消息  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, every one!&quot;</span>;  </span><br><span class="line">    <span class="comment">// 发送消息  </span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;&quot;</span>,message); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="发送订阅-DirectExchange"><a href="#发送订阅-DirectExchange" class="headerlink" title="发送订阅-DirectExchange"></a>发送订阅-DirectExchange<br></h2><p>Direct Exchange会将接收到的消息根据规则路由到指定的Queue，因此称为路由模式（routes）</p>
<ul>
<li>每一个Queue都与Exchange设置一个BindingKey</li>
<li>发布者发送消息时，指定消息的RoutingKey</li>
<li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051455370.png" alt="[Pasted image 20231019101904.png]"></li>
</ul>
<h2 id="利用SpringAMQP演示DirectExchange的使用"><a href="#利用SpringAMQP演示DirectExchange的使用" class="headerlink" title="利用SpringAMQP演示DirectExchange的使用"></a>利用SpringAMQP演示DirectExchange的使用<br></h2><p>实现思路如下：</p>
<ol>
<li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li>
<li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li>
<li>在publisher中编写测试方法，向huanji.direct发送消息<br>步骤1：在consumer服务声明Exchange、Queue</li>
<li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li>
<li>并利用@RabbitListener声明Exchange、Queue、RoutingKey<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException&#123;  </span><br><span class="line">    System.err.println(<span class="string">&quot;消费者接收到fanout.queue2的消息 : 【&quot;</span>+ msg +<span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(  </span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;direct.queue1&quot;),  </span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;huanji.direct&quot;,type = ExchangeTypes.DIRECT),  </span></span><br><span class="line"><span class="meta">        key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;  </span></span><br><span class="line"><span class="meta">))</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirectQueue1</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(  </span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;direct.queue2&quot;),  </span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;huanji.direct&quot;,type = ExchangeTypes.DIRECT),  </span></span><br><span class="line"><span class="meta">        key = &#123;&quot;red&quot;,&quot;yellow&quot;&#125;  </span></span><br><span class="line"><span class="meta">))</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenerDirectQueue2</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤2：在publisher服务发送消息到DirectExchange<br>在publisher服务的SpringAmqpTest类中添加测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//队列名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;huanji.direct&quot;</span>;</span><br><span class="line">	<span class="comment">//消息</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">messge</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>；</span><br><span class="line">	<span class="comment">//发送消息，参数依次为：交换机名称，RoutingKey，消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;red&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="发布订阅-TopicExchange"><a href="#发布订阅-TopicExchange" class="headerlink" title="发布订阅-TopicExchange"></a>发布订阅-TopicExchange<br></h2><p>TopicExchange与DIrectExchange类似，区别在于routingKey必须是多个单词的列表，并且以 . 分割。<br>Queue与Exchange指定BindingKey时可以使用通配符：<br>#: 代指0个或多个单词<br>*: 代指一个单词<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051455355.png" alt="[Pasted image 20231019114704.png]"></p>
<h2 id="利用SpringAMQP演示TopicExchange的使用"><a href="#利用SpringAMQP演示TopicExchange的使用" class="headerlink" title="利用SpringAMQP演示TopicExchange的使用"></a>利用SpringAMQP演示TopicExchange的使用<br></h2><p>实现思路：</p>
<ol>
<li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li>
<li>在consumer服务中，编写两个消息者方法，分别监听topic.queue1和topic.queue2</li>
<li>在publisher中编写测试方法，向huanji.topic发送消息<br>步骤1：在consumer服务声明Exchange、Queue</li>
<li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2，</li>
<li>并利用@RabbitListener声明Exchange、Queue、RoutingKey<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(  </span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topic.queue1&quot;),  </span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;huanji.topic&quot;,type = ExchangeTypes.TOPIC),  </span></span><br><span class="line"><span class="meta">        key = &quot;china.#&quot;  </span></span><br><span class="line"><span class="meta">))</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(  </span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topic.queue2&quot;),  </span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;huanji.topic&quot;,type = ExchangeTypes.TOPIC),  </span></span><br><span class="line"><span class="meta">        key = &quot;#.news&quot;  </span></span><br><span class="line"><span class="meta">))</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤2：在publisher服务发送消息到TopicExchange<br>在publisher服务的SpringAmqpTest类中添加测试方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//队列名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;huanji.topic&quot;</span>;</span><br><span class="line">	<span class="comment">//消息</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">messge</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>；</span><br><span class="line">	<span class="comment">//发送消息，参数依次为：交换机名称，RoutingKey，消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;china.news&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SpringAMQP-消息转换器"><a href="#SpringAMQP-消息转换器" class="headerlink" title="SpringAMQP-消息转换器"></a>SpringAMQP-消息转换器<br></h1><h2 id="测试发送Object类型消息"><a href="#测试发送Object类型消息" class="headerlink" title="测试发送Object类型消息"></a>测试发送Object类型消息<br></h2><p>说明：在SpringAMQP的发送方法中，接收消息的类型是Object，也就是说我们可以发送任意对象类型的消息，SpringAMQP会帮我们序列化为字节后发送。<br>我们在consumer中利用@Bean声明一个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">objectMessageQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在publisher中发送消息以测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">	<span class="comment">//准备消息</span></span><br><span class="line">	Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	msg.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">	msg.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">	<span class="comment">//发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器<br></h2><p>Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。<br>如果要修改只需要定义一个MessageConverter类型的Bean即可。推荐用JSON方式序列化，步骤如下：</p>
<ul>
<li>我们在publisher服务引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>我们在consumer服务定义MessageConverter：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后定义一个消费者，监听object.queue队列并消费消息：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenObjectQueue</span><span class="params">(Map&lt;String,Object&gt; msg)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="初识elasticsearch"><a href="#初识elasticsearch" class="headerlink" title="初识elasticsearch"></a>初识elasticsearch<br></h1><h2 id="什么是elasticsearch"><a href="#什么是elasticsearch" class="headerlink" title="什么是elasticsearch"></a>什么是elasticsearch<br></h2><p>elasticsearch是一款非常强大的开源搜索引擎，可以帮助我们从海量数据中快速找到需要的内容<br>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域<br>elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456510.png" alt="[Pasted image 20231019154919.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456732.png" alt="[Pasted image 20231019155111.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456278.png" alt="[Pasted image 20231019154941.png]"></p>
<h2 id="elasticsearch的发展"><a href="#elasticsearch的发展" class="headerlink" title="elasticsearch的发展"></a>elasticsearch的发展<br></h2><p>Lucene是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。<br>官网地址：(<a target="_blank" rel="noopener" href="https://lucene.apache.org/)%E3%80%82">https://lucene.apache.org/)。</a><br>Lucene的优势：</p>
<ul>
<li>易扩展</li>
<li>高性能（基于倒排索引）<br>Lucene的缺点:</li>
<li>只限于Java语言开发</li>
<li>学习曲线陡峭</li>
<li>不支持水平扩展</li>
</ul>
<p>2004年Shay Banon基于Lucene开发了Compass<br>2010年Shay Banon重写了Compass，取名为Elasticsearch。<br>官网地址：(<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a>)<br>目前最新的版本是：8.10.4<br>相比于lucene，elasticsearch具备下列优势：</p>
<ul>
<li>支持分布式，可水平扩展</li>
<li>提供Restful接口，可被任何语言调用</li>
</ul>
<h2 id="为什么学习elasticsearch？"><a href="#为什么学习elasticsearch？" class="headerlink" title="为什么学习elasticsearch？"></a>为什么学习elasticsearch？<br></h2><p>搜索引擎技术排名：</p>
<ol>
<li>Elasticsearch：开源的分布式搜索引擎</li>
<li>Splunk：商业项目</li>
<li>Solr：Apache的开源搜索引擎</li>
</ol>
<h2 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引<br></h2><p>传统数据库（如MySQL采用正向索引，例如给下表（tb_goods）中的id创建索引）：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456410.png" alt="[Pasted image 20231019161233.png]"><br>elasticsearch采用倒排索引：</p>
<ul>
<li>文档（document）：每条数据就是一个文档</li>
<li>词条（term）：文档按照语义分成的词语<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456380.png" alt="[Pasted image 20231019161720.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051456397.png" alt="[Pasted image 20231019161906.png]"></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档<br></h2><p>elasticsearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息。<br>文档数据会被序列化为json格式后存储在elasticsearch中<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051457217.png" alt="[Pasted image 20231019162626.png]"></p>
<h2 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）<br></h2><ul>
<li>索引（index）：相同类型的文档的集合</li>
<li>映射（mapping）：索引中文档的字段约束信息，类似表的结构约束<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051457882.png" alt="[Pasted image 20231019162834.png]"></li>
</ul>
<h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051457687.png" alt="[Pasted image 20231019163113.png]"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构<br></h2><p>MySQL：擅长事务类型操作，可以确保数据的安全和一致性<br>Elasticsearch：擅长海量数据的搜索、分析、计算<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051457990.png" alt="[Pasted image 20231019163806.png]"></p>
<h2 id="安装elasticsearch、kibana"><a href="#安装elasticsearch、kibana" class="headerlink" title="安装elasticsearch、kibana"></a>安装elasticsearch、kibana<br></h2><p>运行Elasticsearch</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">-e <span class="string">&quot;ES_JAVA_OPTS=-Xms1024m -Xmx1024m&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">-v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">--privileged \</span><br><span class="line">--network es-net \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1 </span><br></pre></td></tr></table></figure>
<p>运行kibana</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=es-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure>

<h2 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器<br></h2><p>es在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。<br>我们在kibana的DevTools中测试：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;黑马程序员学习java太棒了!&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>语法说明：</p>
<ul>
<li>POST：请求方式</li>
<li>&#x2F;_analyze：请求路径，这里省略了<a href="http://192.168.140.130:9200，有kibana帮我们补充">http://192.168.140.130:9200，有kibana帮我们补充</a></li>
<li>请求参数，json风格：<ul>
<li>analyzer：分词器类型，这里是默认的standard分词器</li>
<li>text：要分词的内容<br>  处理中文分词，一般会使用IK分词器。(<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a>)<br>  安装IK分词器，参考资料《安装elasticsearch.md》：<br>  <a href="%E5%AE%89%E8%A3%85elasticsearch.md">[安装elasticsearch]</a></li>
</ul>
</li>
</ul>
<h2 id="ik分词器-模式"><a href="#ik分词器-模式" class="headerlink" title="ik分词器-模式"></a>ik分词器-模式<br></h2><ul>
<li>ik_smart：智能切分，粗粒度<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;蚌埠住了&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>ik_max_word：最细切分，细粒度<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;蚌埠住了&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ik分词器-扩展词库"><a href="#ik分词器-扩展词库" class="headerlink" title="ik分词器-扩展词库"></a>ik分词器-扩展词库<br></h2><p>要扩展ik分词器的词库，只需要修改一个ik分词器目录中的config目录中的IKAnalyzer.cfg.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Aanalyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 * * * 添加扩展词典--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ik分词器-停用词库"><a href="#ik分词器-停用词库" class="headerlink" title="ik分词器-停用词库"></a>ik分词器-停用词库<br></h2><p>要禁用某些敏感词条，只需要修改一个ik分词器目录中的config目录中的IkAnalyzer.cfg.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Aanalyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 用户可以在这里配置自己的扩展停止词字典 * * * 添加停用词词典 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在名为stopword.dic的文件中，添加想要拓展的词语即可</p>
<h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作<br></h1><h2 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性<br></h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li>index：是否创建索引，默认为true</li>
<li>analyzer：使用那种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库<br></h2><p>ES中通过Restful请求操作索引库、文档。请求文档用DSL语句来表示。创建索引库和mapping的DSL语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUt /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	  <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">	    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">	  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">	    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="string">&quot;false&quot;</span></span><br><span class="line">	  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	      <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">	        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">	      <span class="punctuation">&#125;</span></span><br><span class="line">	    <span class="punctuation">&#125;</span></span><br><span class="line">	  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="comment">// ...略</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引库</span><br><span class="line">PUT /heima</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看、删除索引库"><a href="#查看、删除索引库" class="headerlink" title="查看、删除索引库"></a>查看、删除索引库<br></h2><p>查看索引库语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /heima</span><br></pre></td></tr></table></figure>

<p>删除索引库的语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /heima</span><br></pre></td></tr></table></figure>

<h2 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库<br></h2><p>索引库和mapping一旦创建无法修改，但是可以添加新的字段，语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作<br></h1><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档<br></h2><p>新增文档的DSL语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span><span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span><span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span><span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span><span class="string">&quot;值4&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑马程序员Java讲师&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="string">&quot;zy@itcast.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;云&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;赵&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看、删除文档"><a href="#查看、删除文档" class="headerlink" title="查看、删除文档"></a>查看、删除文档<br></h2><p>查看文档语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>删除索引库的语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名/_doc/文档id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档<br></h2><p>方式一：全量修改，会删除旧文档，添加新文档</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="string">&quot;黑马程序员Java讲师&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="string">&quot;ZhaoYun@itcase.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span><span class="string">&quot;云&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span><span class="string">&quot;赵&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式二：增量修改，修改指定字段值</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /heima/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhaoYun@itcast.cn&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="RestClient操作索引库"><a href="#RestClient操作索引库" class="headerlink" title="RestClient操作索引库"></a>RestClient操作索引库<br></h1><h2 id="什么是RestClient"><a href="#什么是RestClient" class="headerlink" title="什么是RestClient"></a>什么是RestClient<br></h2><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<br><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<h2 id="利用JavaRestClient实现创建、删除索引库、判断索引库是否存在"><a href="#利用JavaRestClient实现创建、删除索引库、判断索引库是否存在" class="headerlink" title="利用JavaRestClient实现创建、删除索引库、判断索引库是否存在"></a>利用JavaRestClient实现创建、删除索引库、判断索引库是否存在<br></h2><p>根据课前资料提供的酒店数据创建索引库，索引库名为hotel，mapping属性根据数据库结构定义。<br>基本步骤如下：</p>
<ol>
<li>导入课前资料Demo</li>
<li>分析数据结构，定义mapping属性</li>
<li>初始化JavaRestClient</li>
<li>利用JavaRestClient创建索引库</li>
<li>利用JavaRestClient删除索引库</li>
<li>利用JavaRestClient判断索引库是否存在<br>步骤1：导入课前资料Demo<br>首先导入课前资料提供的数据库数据：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051458501.png" alt="[Pasted image 20231020162716.png]"><br>然后导入课前资料提供的项目：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051458179.png" alt="[Pasted image 20231020162800.png]"><br>步骤2：分析数据结构<br>mapping要考虑的问题：<br>字段名、数据类型、是否参与搜索、是否分词、如果分词，分词器是什么？<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051459239.png" alt="[Pasted image 20231020164505.png]"><br>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;star_name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
步骤3：初始化JavaRestClient</li>
<li>引入es的RestHighLevelClient依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>初始化RestHighLevelClient：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(  </span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.140.130:9200&quot;</span>)  </span><br><span class="line">));</span><br></pre></td></tr></table></figure>
步骤4：创建索引库<br>创建索引库代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1.创建Request对象  </span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句  </span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);  </span><br><span class="line">    <span class="comment">//3.发起请求  </span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤5：删除索引库、判断索引库是否存在</li>
</ol>
<ul>
<li>删除索引库代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1. 创建Request对象  </span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.发起请求  </span></span><br><span class="line">    client.indices().delete(request,RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>判断索引库是否存在<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1.创建Request对象  </span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.发起请求  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(hotel,RequestOptions.DEFAULT);  </span><br><span class="line">    <span class="comment">//3.输出  </span></span><br><span class="line">    System.out.println(exists);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="RestClient操作文档"><a href="#RestClient操作文档" class="headerlink" title="RestClient操作文档"></a>RestClient操作文档<br></h1><h2 id="利用JavaRestClient实现文档的CRUD"><a href="#利用JavaRestClient实现文档的CRUD" class="headerlink" title="利用JavaRestClient实现文档的CRUD"></a>利用JavaRestClient实现文档的CRUD<br></h2><p>去数据库查询酒店数据，导入到hotel索引库，实现酒店数据的CRUD。<br>基本步骤如下：</p>
<ol>
<li>初始化JavaRestClient</li>
<li>利用JavaRestClient新增酒店数据</li>
<li>利用JavaRestClient根据id查询酒店数据</li>
<li>利用JavaRestClient删除酒店数据</li>
<li>利用JavaRestClient修改酒店数据<br> 步骤1：初始化JavaRestClient<br> 新建一个测试类，实现文档相关操作，并且完成JavaRestClient的初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchDocumentTest</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">	<span class="meta">@BeforeEach</span>  </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;  </span><br><span class="line">	    <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(  </span><br><span class="line">	            HttpHost.create(<span class="string">&quot;http://192.168.140.130:9200&quot;</span>)  </span><br><span class="line">	    ));  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="meta">@AfterEach</span>  </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">	    <span class="built_in">this</span>.client.close();  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤2：添加酒店数据到索引库<br>  先查询酒店数据，然后给这条数据创建倒排索引，即可完成添加：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//根据id查看酒店数据  </span></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelService.getById(<span class="number">36934L</span>);  </span><br><span class="line">    <span class="comment">//转换为文档类型  </span></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//1.准备Request对象  </span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());  </span><br><span class="line">    <span class="comment">//2.准备JSON文档  </span></span><br><span class="line">    indexRequest.source(JSON.toJSONString(hotelDoc),XContentType.JSON);  </span><br><span class="line">    client.index(indexRequest,RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤3：根据id查询酒店数据<br>  根据id查询到的文档数据是json，需要反序列化为json对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1.创建Request对象  </span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.请求参数，MAPPING_TEMPLATE是静态常量字符串，内容是创建索引库的DSL语句  </span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);  </span><br><span class="line">    <span class="comment">//3.发起请求  </span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤4：根据id修改酒店数据<br>  修改文档数据有两种方式：<br>  方式一：全量更新。再次写入id一样的文档，就会删除旧文档，添加新文档<br>  方式二：局部更新。只更新部分字段，我们演示方式二<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1.准备Request  </span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">hotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;36934&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.准备请求参数  </span></span><br><span class="line">    hotel.doc(  </span><br><span class="line">        <span class="string">&quot;price&quot;</span>,<span class="string">&quot;700&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;starName&quot;</span>,<span class="string">&quot;四钻&quot;</span>  </span><br><span class="line">    );  </span><br><span class="line">    <span class="comment">//3.发送请求  </span></span><br><span class="line">    client.update(hotel,RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤5：根据id删除文档数据<br>  删除文档代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//1.准备Request  </span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;36934&quot;</span>);  </span><br><span class="line">    <span class="comment">//2.发送请求  </span></span><br><span class="line">    client.delete(request,RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="利用JavaRestClient批量导入酒店数据到ES"><a href="#利用JavaRestClient批量导入酒店数据到ES" class="headerlink" title="利用JavaRestClient批量导入酒店数据到ES"></a>利用JavaRestClient批量导入酒店数据到ES<br></h2><p>需求：批量查询酒店数据，然后批量导入索引库中<br>思路：</p>
<ol>
<li>利用mybatis-plus查询酒店数据</li>
<li>将查询到的酒店数据(Hotel)转换为文档类型数据(HotelDoc)</li>
<li>利用JavaRestClient中的Bulk批处理，实现批量新增文档，示例代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">    <span class="comment">//批量查询酒店数据  </span></span><br><span class="line">    List&lt;Hotel&gt; list = hotelService.list();  </span><br><span class="line">    <span class="comment">//1.创建Request  </span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();  </span><br><span class="line">    <span class="comment">//2.准备参数  </span></span><br><span class="line">    list.stream().map(arg -&gt; <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(arg)).collect(Collectors.toList()).forEach((arg) -&gt; &#123;  </span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>)  </span><br><span class="line">                .id(arg.getId().toString())  </span><br><span class="line">                .source(JSON.toJSONString(arg),XContentType.JSON));  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="comment">//3.发送请求  </span></span><br><span class="line">    client.bulk(request,RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="DSL查询语法"><a href="#DSL查询语法" class="headerlink" title="DSL查询语法"></a>DSL查询语法<br></h1><h2 id="DSL-Query的分类"><a href="#DSL-Query的分类" class="headerlink" title="DSL Query的分类"></a>DSL Query的分类<br></h2><p>Elasticasearch提供了基于JSON的DSL（Domain Specific Language）来定义查询。常见的查询类型包括：</p>
<ul>
<li>查询所有：查询出所有数据，一般测试用。例如：match_all</li>
<li>全文检索（full text）查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
</li>
<li>精确查询：根据精确词条查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
</li>
<li>地理（geo）查询：根据经纬度查询。例如：<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
</li>
<li>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<ul>
<li>bool</li>
<li>function_score</li>
</ul>
</li>
</ul>
<h2 id="DSL-Query基本语法"><a href="#DSL-Query基本语法" class="headerlink" title="DSL Query基本语法"></a>DSL Query基本语法<br></h2><p>查询的基本语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span><span class="punctuation">:</span> <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询<br></h2><p>全文检索查询，会对用户输入内容分词，常用于搜索框搜索：</p>
<p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051459387.png" alt="[Pasted image 20231021144312.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051459167.png" alt="[Pasted image 20231021144417.png]"></p>
<p>match查询：全文检索查询的一种，会对用户输入内容分词，然后去倒排索引库检索，语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>multi_match：与match查询类似，只不过允许同时查询多个字段，语法：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FIELD1&quot;</span><span class="punctuation">,</span><span class="string">&quot;FIELD12&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询<br></h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有：</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<h2 id="精确查询-语法"><a href="#精确查询-语法" class="headerlink" title="精确查询-语法"></a>精确查询-语法<br></h2><p>精确查询一般是根据id、数值、keyword类型、或布尔字段来查询。语法如下：<br>term查询：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>range查询：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">400</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="地理查询"><a href="#地理查询" class="headerlink" title="地理查询"></a>地理查询<br></h2><p>根据经纬度查询。常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人<br>根据经纬度查询，例如：</li>
<li>geo_bounding_box：查询geo_point值落在某个矩形范围的所有文档<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.7</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>geo_distance：查询到指定中心点小于某个距离值的所有文档<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;distance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15km&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.21,121.5&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询<br></h2><p>复合（compound）查询：复合查询可以将其他简单查询组合起来，实现更复杂的搜索逻辑，例如：</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名。例如百度竞价</li>
</ul>
<h2 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分<br></h2><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。<br>例如，我们搜索”虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;虹桥如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;外滩如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;迪士尼如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>elsasticsearch中的相关性打分算法:</p>
<ul>
<li>TF-IDF：在elasticsearch5.0之前，会随着词频增加而越来越大<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051500922.png" alt="[Pasted image 20231022083816.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051500208.png" alt="[Pasted image 20231022083829.png]"></li>
<li>BM25：在elasticsearch5.0之后，会随着词频增加而增大，但增长曲线会趋于水平<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051500193.png" alt="[Pasted image 20231022083852.png]"></li>
</ul>
<h2 id="Function-Score-Query"><a href="#Function-Score-Query" class="headerlink" title="Function Score Query"></a>Function Score Query<br></h2><p>使用function score query，可以修改文档的相关性算分（query score），根据新得到的算分排序。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;all&quot;</span><span class="punctuation">:</span> <span class="string">&quot;外滩&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiply&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>“query”: { “match”: {“all”: “外滩”}}：<br>原始查询条件，搜索文档并根据相关性打分（query_score）</li>
<li>“filter”: {“term”: {“id”: “1”}}：<br>过滤条件，符合条件的文档才会被重新算分</li>
<li>“weight”: 10<br>算分函数，算分函数的结果称为function_score，将来会与query score运算，得到新算法，常见的算分函数有：<ul>
<li>weight：给一个常量值，作为函数结果（function score）</li>
<li>field_value_factor：用文档中的某个字段值作为函数结果</li>
<li>random_score：随机生成一个值，作为函数结果</li>
<li>script_score：自定义计算公式，公式结果作为函数结果</li>
</ul>
</li>
<li>“boost_mode”: “multiply”<br>加权模式，定义function score与query_score的运算方式，包括：<ul>
<li>multiply：两者相乘。默认就是这个</li>
<li>replace：用function score替换query score</li>
<li>其他：sum、avg、max、min</li>
</ul>
</li>
</ul>
<h3 id="给“如家”这个品牌的酒店排名靠前一点"><a href="#给“如家”这个品牌的酒店排名靠前一点" class="headerlink" title="给“如家”这个品牌的酒店排名靠前一点"></a><strong>给“如家”这个品牌的酒店排名靠前一点</strong><br></h3><p>把这个问题翻译一下，function score需要的三要素：</p>
<ol>
<li>那些文档需要算分加权？<ul>
<li>品牌为如家的酒店</li>
</ul>
</li>
<li>算分函数是什么？<ul>
<li>weight就可以</li>
</ul>
</li>
<li>加权模式是什么？<ul>
<li>求和<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//算分函数</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="comment">//算分权重为2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>function score query三要素:</p>
<ul>
<li>过滤条件：哪些文档要加分</li>
<li>算分函数：如何计算function score</li>
<li>加权方式：function score与 query score如何运算</li>
</ul>
<h2 id="复合查询-Boolean-Query"><a href="#复合查询-Boolean-Query" class="headerlink" title="复合查询 Boolean Query"></a>复合查询 Boolean Query<br></h2><p>布尔查询是一个或多个查询子句的组合。子查询的组合方式有：</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，不参与算分，类似“非”</li>
<li>filter：必须匹配，不参与算分<br>示例:<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;上海&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;皇冠假日&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="string">&quot;华美达&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;get&quot;</span><span class="punctuation">:</span> <span class="number">45</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="利用bool查询实现功能"><a href="#利用bool查询实现功能" class="headerlink" title="利用bool查询实现功能"></a><strong>利用bool查询实现功能</strong><br></h3><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21，121.5周围10km范围内的酒店</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">	          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;gt&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;distance&quot;</span><span class="punctuation">:</span><span class="string">&quot;10km&quot;</span><span class="punctuation">,</span><span class="attr">&quot;location&quot;</span><span class="punctuation">:</span></span><br><span class="line">              <span class="punctuation">&#123;</span><span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span><span class="number">31.21</span><span class="punctuation">,</span><span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span><span class="number">121.5</span><span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="搜索结果处理"><a href="#搜索结果处理" class="headerlink" title="搜索结果处理"></a>搜索结果处理<br></h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序<br></h2><p>elasticsearch支持对搜索结果排序，默认是根据相关度算分（_score）来排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="comment">//排序字段和排序方式ASC、DESC</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;纬度,经度&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;km&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现对酒店数据按照到你的位置坐标的距离升序排序"><a href="#实现对酒店数据按照到你的位置坐标的距离升序排序" class="headerlink" title="实现对酒店数据按照到你的位置坐标的距离升序排序"></a><strong>实现对酒店数据按照到你的位置坐标的距离升序排序</strong><br></h3><p>获取经纬度的方式：(<a target="_blank" rel="noopener" href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a>)</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">31.034661</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.612282</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;km&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页<br></h2><p>elasticsearch默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。<br>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">//分页开始的位置，默认为0</span></span><br><span class="line">	  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">//期望获取的文档总数</span></span><br><span class="line">	  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">	    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">	  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题<br></h2><p>ES是分布式的，所以会面临深度分页问题。例如按price排序后，获取from&#x3D;990，size&#x3D;10的数据：</p>
<ol>
<li>首先在每个数据分片上都排序并查询前1000条文档。</li>
<li>然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档</li>
<li>最后从这1000条中，选取从990开始的10条文档<br>如果搜索页数过深，或者结果集（from + size）越大，对内存和CPU的消耗也越高。因此ES设定结果集查询的上限是10000<br>![[Pasted image 20231024075341.png]]</li>
</ol>
<h2 id="深度分页解决方案"><a href="#深度分页解决方案" class="headerlink" title="深度分页解决方案"></a>深度分页解决方案<br></h2><p>针对深度分页，ES提供了两种解决方案，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paqinate-search-results.html">官方文档</a>：</p>
<ul>
<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式</li>
<li>scroll：原理将排序数据形成快照，保存在内存。官方已经不推荐使用</li>
</ul>
<h2 id="分页总结"><a href="#分页总结" class="headerlink" title="分页总结"></a>分页总结<br></h2><p>from + size:</p>
<ul>
<li>优点：支持随机翻页</li>
<li>缺点：深度分页问题，默认查询上限（from + size）是10000</li>
<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索<br>after search：</li>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：只能向后逐页查询，不支持随机翻页</li>
<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页<br>scroll：</li>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用after search方案。</li>
</ul>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮<br></h2><p>高亮：就是在搜索结果中把搜索关键字突出显示。<br>原理是这样的：</p>
<ul>
<li>将搜索结果中的关键字用标签标记出来</li>
<li>在页面中给标签添加css样式<br>语法：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span><span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">		<span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">//用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="搜索结果处理整体语法"><a href="#搜索结果处理整体语法" class="headerlink" title="搜索结果处理整体语法"></a>搜索结果处理整体语法<br></h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">//分页开始的位置</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="comment">//期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">//普通排序</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//距离排序</span></span><br><span class="line">        <span class="attr">&quot;location&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;31.040699,121.618075&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;km&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//高亮字段</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span> <span class="comment">//用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span><span class="punctuation">,</span> <span class="comment">//用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="RestClient查询文档"><a href="#RestClient查询文档" class="headerlink" title="RestClient查询文档"></a>RestClient查询文档<br></h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门<br></h2><p>我们通过match_all来演示下基本的API，先看请求的DSL的组织：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">  <span class="comment">//1.准备Request</span></span><br><span class="line">  <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">  <span class="comment">//2.组织DSL参数</span></span><br><span class="line">  request.source()</span><br><span class="line">	     .query(QueryBuilders.matchAllQuery());</span><br><span class="line">  <span class="comment">//3.发送请求，得到响应结果</span></span><br><span class="line">  <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request,RequestOptions.DEFAULT)；</span><br><span class="line">  <span class="comment">//...解析响应结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看结果的解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throw</span> IOException &#123;</span><br><span class="line">	<span class="comment">// ...略</span></span><br><span class="line">	<span class="comment">//4.解析结果  </span></span><br><span class="line">	<span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> search.getHits();  </span><br><span class="line">	<span class="comment">//4.1.查询的总条数  </span></span><br><span class="line">	<span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> searchHits.getTotalHits().value;  </span><br><span class="line">	<span class="comment">//4.2.查询的结果数组  </span></span><br><span class="line">	SearchHit[] hits = searchHits.getHits();  </span><br><span class="line">	<span class="keyword">for</span> (SearchHit hit : hits) &#123;  </span><br><span class="line">	    <span class="comment">//4.3.得到source  </span></span><br><span class="line">	    <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();  </span><br><span class="line">	    System.out.println(searchHits);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RestAPI中其中构建DSL是通过HighLevelRestClient中的resource()来实现的，其中包含了查询、排序、分页、高亮等所有功能:<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051500527.png" alt="[Pasted image 20231024101117.png]"><br>RestAPI中其中构建查询条件的核心部分是由一个名为QueryBuilders的工具类提供的，其中包含了各种查询方法：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051501386.png" alt="[Pasted image 20231024101308.png]"></p>
<h2 id="全文检索查询-1"><a href="#全文检索查询-1" class="headerlink" title="全文检索查询"></a>全文检索查询<br></h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。<br>同样是利用QueryBuilders提供的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单字段查询</span></span><br><span class="line">QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>,<span class="string">&quot;如家&quot;</span>);</span><br><span class="line"><span class="comment">//多字段查询</span></span><br><span class="line">QueryBuilders.multiMatchQuery(<span class="string">&quot;如家&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;business&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="精确查询-1"><a href="#精确查询-1" class="headerlink" title="精确查询"></a>精确查询<br></h2><p>精确查询常见的有term查询和range查询，同样利用QueryBuilders实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词条查询</span></span><br><span class="line">QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>,<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"><span class="comment">// 范围查询</span></span><br><span class="line">QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">100</span>).lte(<span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<h2 id="复合查询-boolean-query"><a href="#复合查询-boolean-query" class="headerlink" title="复合查询-boolean query"></a>复合查询-boolean query<br></h2><p>精确查询常见的有term查询和range查询，同样利用QueryBuilders实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建布尔查询</span></span><br><span class="line"><span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"><span class="comment">//添加must条件</span></span><br><span class="line">boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>,<span class="string">&quot;杭州&quot;</span>));</span><br><span class="line"><span class="comment">//添加filter条件</span></span><br><span class="line">boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br></pre></td></tr></table></figure>
<h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页<br></h2><p>搜索结果的排序和分页是与query同级的参数，对应的API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line"><span class="comment">//分页</span></span><br><span class="line">request.source().from(<span class="number">0</span>).size(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//价格排序</span></span><br><span class="line">request.source().sort(<span class="string">&quot;price&quot;</span>,SortOrder.ASC);</span><br></pre></td></tr></table></figure>

<h2 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮<br></h2><p>高亮API包括请求DSL构建和结果解析两部分。我们先看请求的DSL构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>)</span><br><span class="line">	   .field(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	   <span class="comment">//是否需要与查询字段匹配</span></span><br><span class="line">	   .requireFieldMatch(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h2 id="高亮结果解析"><a href="#高亮结果解析" class="headerlink" title="高亮结果解析"></a>高亮结果解析<br></h2><p>高亮的结果处理相对比较麻烦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.3.得到source  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();  </span><br><span class="line"><span class="comment">//反序列化  </span></span><br><span class="line"><span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(sourceAsString, HotelDoc.class);  </span><br><span class="line"><span class="comment">//获取高亮结果  </span></span><br><span class="line">Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();  </span><br><span class="line"><span class="keyword">if</span>(!CollectionUtils.isEmpty(highlightFields))&#123;  </span><br><span class="line">    <span class="comment">//根据字段名获取高亮结果  </span></span><br><span class="line">    <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>(highlightField != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">//获取高亮值  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();  </span><br><span class="line">        <span class="comment">//覆盖非高亮结果  </span></span><br><span class="line">        hotelDoc.setName(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="黑马旅游案例"><a href="#黑马旅游案例" class="headerlink" title="黑马旅游案例"></a>黑马旅游案例<br></h1><h2 id="案例1：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页"><a href="#案例1：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页" class="headerlink" title="案例1：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页"></a>案例1：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页<br></h2><p>课前提供的hotel-demo项目中，自带了前端页面，启动后可以看到：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051501005.png" alt="[Pasted image 20231024120216.png]"><br>先实现其中的关键字搜索功能，实现步骤如下：</p>
<ol>
<li>定义实体类，接收前端请求</li>
<li>定义controller接口，接收页面请求，调用IHotelService的search方法</li>
<li>定义IHotelService中的search方法，利用match查询实现根据关键字搜索酒店信息<br> <strong>步骤1：定义类，接收前端请求参数</strong><br> 格式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParms</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String key;</span><br><span class="line">	<span class="keyword">private</span> Integer page;</span><br><span class="line">	<span class="keyword">private</span> Integer size;</span><br><span class="line">	<span class="keyword">private</span> String sortBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>步骤2：定义controller接口，接收前端请求</strong><br>定义一个HotelController，声明查询接口，满足下列要求：</li>
</ol>
<ul>
<li>请求方式：Post</li>
<li>请求路径：&#x2F;hotel&#x2F;list</li>
<li>请求参数：对象，类型为RequestParam</li>
<li>返回值：PageResult，包含两个属性<ul>
<li>Long total：总条数</li>
<li>List&lt;HotelDoc&gt; hotels: 酒店数据</li>
</ul>
</li>
</ul>
<h2 id="案例2：添加品牌、城市、星级、价格等过滤功能"><a href="#案例2：添加品牌、城市、星级、价格等过滤功能" class="headerlink" title="案例2：添加品牌、城市、星级、价格等过滤功能"></a>案例2：添加品牌、城市、星级、价格等过滤功能<br></h2><p>步骤：</p>
<ol>
<li>修改RquestParams类，添加brand、city、starName、minPrice、maxPrice等参数</li>
<li>修改search方法的实现，在关键字搜索时，如果brand等参数存在，对其做过滤<br><strong>步骤一：扩展IUserService的search方法的参数列表</strong><br>修改RequestParms类，接收所有参数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String key;  </span><br><span class="line">	<span class="keyword">private</span> Integer page;  </span><br><span class="line">	<span class="keyword">private</span> Integer size;  </span><br><span class="line">	<span class="keyword">private</span> String sortBy;  </span><br><span class="line">	<span class="keyword">private</span> String brand;  </span><br><span class="line">	<span class="keyword">private</span> String starName;  </span><br><span class="line">	<span class="keyword">private</span> String city;  </span><br><span class="line">	<span class="keyword">private</span> Integer minPrice;  </span><br><span class="line">	<span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>步骤二：修改search方法，在match查询基础上添加过滤条件</strong><br>过滤条件包括：</li>
</ol>
<ul>
<li>city精确匹配</li>
<li>brand精确匹配</li>
<li>starName精确匹配</li>
<li>price范围过滤<br>注意事项：</li>
<li>多个条件之间是AND关系，组合多条件用BooleanQuery</li>
<li>参数存在才需要过滤，做好非空判断</li>
</ul>
<h2 id="案例3：我附近的酒店"><a href="#案例3：我附近的酒店" class="headerlink" title="案例3：我附近的酒店"></a>案例3：我附近的酒店<br></h2><p>前端页面点击后，会将你所在位置发送到后台：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051501431.png" alt="[Pasted image 20231024173047.png]"><br>我们要根据这个坐标，将酒店结果按照到这个点的距离升序排序<br>实现思路如下：</p>
<ul>
<li>修改RequestParams参数，接收location字段</li>
<li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li>
</ul>
<h3 id="距离排序"><a href="#距离排序" class="headerlink" title="距离排序"></a><strong>距离排序</strong><br></h3><p>距离排序与普通排序有所差异，API如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//价格排序</span></span><br><span class="line">request.source().sort(<span class="string">&quot;price&quot;</span>,SortOrder.ASC);</span><br><span class="line"><span class="comment">//距离排序</span></span><br><span class="line">request.source().sort(SortBuilders</span><br><span class="line">	.geoDistanceSort(<span class="string">&quot;location&quot;</span>,<span class="keyword">new</span> <span class="title class_">GeoPoint</span>(<span class="string">&quot;31.21,121.5&quot;</span>))</span><br><span class="line">	.order(SortOrder.ASC)</span><br><span class="line">	.unit(DistanceUnit.KILOMETERS)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="案例4：让指定的酒店在搜索结果中排名置顶"><a href="#案例4：让指定的酒店在搜索结果中排名置顶" class="headerlink" title="案例4：让指定的酒店在搜索结果中排名置顶"></a>案例4：让指定的酒店在搜索结果中排名置顶<br></h2><p>我们给需要置顶的酒店文档添加标记。然后利用function score给带有标记的文档增加权重<br>实现步骤分析：</p>
<ol>
<li>给HotelDoc类添加isAD字段，Boolean类型</li>
<li>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</li>
<li>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</li>
</ol>
<h3 id="组合查询-function-score"><a href="#组合查询-function-score" class="headerlink" title="组合查询-function score"></a><strong>组合查询-function score</strong></h3><p>Function Score查询可以控制文档的相关性算分，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQueryBuilder</span> <span class="operator">=</span> </span><br><span class="line">	QueryBuilders.functionScoreQuery(</span><br><span class="line">		QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;外滩&quot;</span>),</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">				QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>,<span class="string">&quot;如家&quot;</span>),</span><br><span class="line">				ScoreFunctionBuilders.weightFactorFunction(<span class="number">5</span>)</span><br><span class="line">			)</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">sourceBuilder.query(functionScoreQueryBuilder);</span><br></pre></td></tr></table></figure>

<h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合<br></h1><h2 id="聚合的分类"><a href="#聚合的分类" class="headerlink" title="聚合的分类"></a>聚合的分类<br></h2><p>聚合（aggregations）可以实现对文档数据的统计、分析、运算。聚合常见的有三类：</p>
<ul>
<li>桶（Bucket）聚合：用来对文档做分组<ul>
<li>TermAggregation：按照文档字段值分组</li>
<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>
</ul>
</li>
<li>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等<ul>
<li>Avg：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stans：同时求max、min、avg、sum等</li>
</ul>
</li>
<li>管道（pipeline）聚合：其它聚合的结果为基础做聚合</li>
</ul>
<h2 id="DSL实现Bucket聚合"><a href="#DSL实现Bucket聚合" class="headerlink" title="DSL实现Bucket聚合"></a>DSL实现Bucket聚合<br></h2><p>现在，我们要统计所有数据中的酒店品牌有几种，此时可以根据酒店品牌的名称做聚合。<br>类型为term类型，DSL示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">//设置size为0，结果中不包含文档,只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//给聚合起个名字</span></span><br><span class="line">	    <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">		    <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> <span class="comment">//参与聚合的字段</span></span><br><span class="line">		    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">//希望获取的聚合结果数量</span></span><br><span class="line">	      </span><br><span class="line">	    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Bucket聚合-聚合结果排序"><a href="#Bucket聚合-聚合结果排序" class="headerlink" title="Bucket聚合-聚合结果排序"></a>Bucket聚合-聚合结果排序<br></h2><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。<br>我们可以修改结果排序方式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="comment">//按照_count升序排序</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Bucket聚合-限定聚合范围"><a href="#Bucket聚合-限定聚合范围" class="headerlink" title="Bucket聚合-限定聚合范围"></a>Bucket聚合-限定聚合范围<br></h2><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，我们可以限定要聚合的文档范围，只要添加query条件即可：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">//只对200元以下的文档聚合</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="DSL实现Metrics聚合"><a href="#DSL实现Metrics聚合" class="headerlink" title="DSL实现Metrics聚合"></a>DSL实现Metrics聚合<br></h2><p>例如，我们要求获取每个品牌的用户评分的min、max、avg等值<br>我们可以利用stats聚合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">	         <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;score&quot;</span> <span class="comment">//聚合字段，这里是score   </span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span>   </span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="RestAPi实现聚合"><a href="#RestAPi实现聚合" class="headerlink" title="RestAPi实现聚合"></a>RestAPi实现聚合<br></h2><p>我们以品牌聚合为例，演示下Java的RestClient使用，先看请求组装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.source().size(<span class="number">0</span>);</span><br><span class="line">request.source().aggregation(</span><br><span class="line">	AggregationBuilders</span><br><span class="line">		.terms(<span class="string">&quot;brand_agg&quot;</span>)</span><br><span class="line">		.field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">		.size(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>再看下聚合结果解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析聚合结果  </span></span><br><span class="line"><span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> search.getAggregations();  </span><br><span class="line"><span class="comment">//根据名称获取聚合结果  </span></span><br><span class="line"><span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;brandAgg&quot;</span>);  </span><br><span class="line"><span class="comment">//获取桶  </span></span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();  </span><br><span class="line"><span class="comment">//遍历  </span></span><br><span class="line"><span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;  </span><br><span class="line">    <span class="comment">//获取key，也就是品牌信息  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> bucket.getKeyAsString();  </span><br><span class="line">    System.out.println(brandName);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="案例：在IUservice中定义方法，实现对品牌、城市、星级的聚合"><a href="#案例：在IUservice中定义方法，实现对品牌、城市、星级的聚合" class="headerlink" title="案例：在IUservice中定义方法，实现对品牌、城市、星级的聚合"></a>案例：在IUservice中定义方法，实现对品牌、城市、星级的聚合<br></h2><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：<br>在IUservice中定义一个方法，实现对品牌、城市、星级的聚合，方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filter</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="对接前端接口"><a href="#对接前端接口" class="headerlink" title="对接前端接口"></a>对接前端接口<br></h2><p>前端页面会向服务端发起请求，查询品牌、城市、星级等字段的聚合结果：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051501803.png" alt="[Pasted image 20231025160138.png]"><br>可以看到请求参数与之前search时的RequestParam完全一致，这是在限定聚合时的文档范围。<br>例如：用户搜索”外滩“，价格在300~600，那聚合必须是在这个搜索条件基础上完成。<br>因此我们需要：</p>
<ol>
<li>编写controller接口，接收该请求</li>
<li>修改IUserService#getFilters()方法，添加RequestParam参数</li>
<li>修改getFilters方法的业务，聚合时添加query条件</li>
</ol>
<h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全<br></h1><h2 id="自动补全需求说明"><a href="#自动补全需求说明" class="headerlink" title="自动补全需求说明"></a>自动补全需求说明<br></h2><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051501057.png" alt="[Pasted image 20231025164202.png]"></p>
<h2 id="使用拼音分词"><a href="#使用拼音分词" class="headerlink" title="使用拼音分词"></a>使用拼音分词<br></h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：(<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a>)<br>安装方式与IK分词器一样，分三步：</p>
<ol>
<li>解压</li>
<li>上传到虚拟机中，elasticsearch的plugin目录</li>
<li>重启elasticsearch</li>
<li>测试<br>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;如家酒店还不错&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span> <span class="comment">//拼音分词器</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="自定义分词器"><a href="#自定义分词器" class="headerlink" title="自定义分词器"></a>自定义分词器<br></h2><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p>
<ul>
<li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分次；还有ik_smart</li>
<li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等<br>我们可以在创建索引库时，通过settings来配置自定义的analyzer（分词器）：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//过滤器名称</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span> <span class="comment">//过滤器类型，这里是pinyin</span></span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chiness_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>拼音分词器适合在创建倒排索引的时候使用，但不能在搜索的时候使用。<br>创建倒排索引时：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051502882.png" alt="[Pasted image 20231026092538.png]"><br>搜索时，用户搜索“狮子”：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051502247.png" alt="[Pasted image 20231026092606.png]"><br>因此字段在创建倒排索引时应该用my_analyzer分词器；字段在搜索时应该使用ik_smart分词器；</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">//自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_analyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="completion-suggester查询"><a href="#completion-suggester查询" class="headerlink" title="completion suggester查询"></a>completion suggester查询<br></h2><p>elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p>
<ul>
<li>参与补全查询的字段必须是completion类型。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">PUT test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>字段的内容一般是用来补全的多个词条组成的数组<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例数据</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;Sony&quot;</span><span class="punctuation">,</span><span class="string">&quot;WH-1000XM3&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;SK-II&quot;</span><span class="punctuation">,</span><span class="string">&quot;PITERA&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;Nintendo&quot;</span><span class="punctuation">,</span><span class="string">&quot;switch&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
查询语法如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="comment">// 关键字</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span> <span class="comment">//补全查询的字段</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 跳过重复的</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">//获取前10条结果</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="案例：实现hotel索引库的自动补全、拼音搜索功能"><a href="#案例：实现hotel索引库的自动补全、拼音搜索功能" class="headerlink" title="案例：实现hotel索引库的自动补全、拼音搜索功能"></a>案例：实现hotel索引库的自动补全、拼音搜索功能<br></h2><p>实现思路如下：</p>
<ol>
<li>修改hotel索引库结构，设置自定义拼音分词器</li>
<li>修改索引库的name、all字段，使用自定义分词器</li>
<li>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</li>
<li>给HotelDoc类添加suggestion字段，内容包含brand、business</li>
<li>重新导入数据到hotel库</li>
</ol>
<h2 id="RestAPI实现自动补全"><a href="#RestAPI实现自动补全" class="headerlink" title="RestAPI实现自动补全"></a>RestAPI实现自动补全<br></h2><p>先看请求参数的构造API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.准备请求</span></span><br><span class="line"><span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line"><span class="comment">//2.请求参数</span></span><br><span class="line">request.source()</span><br><span class="line">	.suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">			<span class="string">&quot;mySuggestion&quot;</span>,</span><br><span class="line">			SuggestBuilders</span><br><span class="line">					.completionSuggestion(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">					.prefix(<span class="string">&quot;h&quot;</span>)</span><br><span class="line">					.skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">					.size(<span class="number">10</span>)</span><br><span class="line">	));</span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">client.search(request,RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>对应:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;suggestions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;suggestion&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>再来看结果解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.处理结果</span></span><br><span class="line"><span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line"><span class="comment">//4.1.根据名称获取补全结果</span></span><br><span class="line"><span class="type">CompletionSuggestion</span> <span class="variable">suggestion</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">&quot;hotelSuggestion&quot;</span>);</span><br><span class="line"><span class="comment">//4.2.获取options并遍历</span></span><br><span class="line"><span class="keyword">for</span>(CompletionSuggestion.Entry.Option option : suggestion.getOptions())&#123;</span><br><span class="line">	<span class="comment">//4.3.获取一个option中的text，也就是补全的词条</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().string();</span><br><span class="line">	System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现酒店搜索页面输入框的自动补全"><a href="#实现酒店搜索页面输入框的自动补全" class="headerlink" title="实现酒店搜索页面输入框的自动补全"></a>实现酒店搜索页面输入框的自动补全<br></h2><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503713.png" alt="[Pasted image 20231030091238.png]"><br>在服务端编写接口，接收该请求，返回补全结果的集合，类型为LIst&lt;string&gt;</p>
<h1 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步<br></h1><h2 id="数据同步问题分析"><a href="#数据同步问题分析" class="headerlink" title="数据同步问题分析"></a>数据同步问题分析<br></h2><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticearch也必须发生改变，这个就是elasticearch与mysql之间的数据同步</p>
<p>在微服务中，负责酒店管理（操作mysql）的业务与负责酒店搜索（操作elasticsearch）的业务可能在两个不同的微服务上，数据同步该如何实现呢？<br>方案一：同步调用</p>
<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503801.png" alt="[Pasted image 20231030093438.png]"><br>方案二：异步通知</li>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖mq的可靠性<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503502.png" alt="[Pasted image 20231030093851.png]"><br>方案三：监听binlog</li>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启binlog增加数据库负担、实现复杂度高<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503771.png" alt="[Pasted image 20231030093940.png]"></li>
</ul>
<h2 id="利用MQ实现mysql与elasticearch数据同步"><a href="#利用MQ实现mysql与elasticearch数据同步" class="headerlink" title="利用MQ实现mysql与elasticearch数据同步"></a>利用MQ实现mysql与elasticearch数据同步<br></h2><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。<br>步骤：</p>
<ul>
<li>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</li>
<li>声明exchange、queue、RoutingKey</li>
<li>在hotel-admin中的增、删、改业务中完成消息发送</li>
<li>在hotel-demo中完成消息监听，并更新elasticsearch中数据</li>
<li>启动并测试数据同步功能</li>
</ul>
<h1 id="elasticsearch集群"><a href="#elasticsearch集群" class="headerlink" title="elasticsearch集群"></a>elasticsearch集群<br></h1><h2 id="ES集群结构"><a href="#ES集群结构" class="headerlink" title="ES集群结构"></a>ES集群结构<br></h2><p>单击的elasticserch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>
<ul>
<li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503832.png" alt="[Pasted image 20231030154015.png]"></li>
<li>单点故障问题：将分片数据在不同节点备份（replica）<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051503149.png" alt="[Pasted image 20231030154323.png]"></li>
</ul>
<h2 id="搭建ES集群"><a href="#搭建ES集群" class="headerlink" title="搭建ES集群"></a>搭建ES集群<br></h2><p>我们计划利用3个docker容器模拟3个es的节点。具体步骤参考elasticsearch第一天课程的课前资料：<br><a href="%E5%AE%89%E8%A3%85elasticsearch">[安装elasticsearch]</a></p>
<h2 id="ES集群的节点角色"><a href="#ES集群的节点角色" class="headerlink" title="ES集群的节点角色"></a>ES集群的节点角色<br></h2><p>elasticsearch中集群节点有不同的职责划分：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051504664.png" alt="[Pasted image 20231031084716.png]"><br>elasticsearch中的每个节点角色都有不同的职责，因此建议集群部署时，每个节点都有独立的角色。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051504692.png" alt="[Pasted image 20231031090955.png]"></p>
<h2 id="ES集群的脑裂"><a href="#ES集群的脑裂" class="headerlink" title="ES集群的脑裂"></a>ES集群的脑裂<br></h2><p>默认情况下，每个节点都是master eligible节点，因此一旦master节点宕机，其他候选节点会选举一个成为主节点。当主节点与其他节点网络故障时，可能发生脑裂问题。<br>为了避免脑裂，需要要求选票超过(eligible节点数量+1)&#x2F;2才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051504742.png" alt="[Pasted image 20231031091948.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505924.png" alt="[Pasted image 20231031091652.png]"></p>
<h2 id="ES集群的分布式存储"><a href="#ES集群的分布式存储" class="headerlink" title="ES集群的分布式存储"></a>ES集群的分布式存储<br></h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？<br>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505945.png" alt="[Pasted image 20231031104133.png]"><br>说明：</p>
<ul>
<li>_routing默认是文档的id</li>
<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！<br>新增文档流程：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505846.png" alt="[Pasted image 20231031111704.png]"><br>elasticsearch的查询分成两个阶段：</li>
<li>scatter phase：分散阶段，coordinating node会把请求分发到每一个切片</li>
<li>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505903.png" alt="[Pasted image 20231031112206.png]"></li>
</ul>
<h2 id="ES集群的故障转移"><a href="#ES集群的故障转移" class="headerlink" title="ES集群的故障转移"></a>ES集群的故障转移<br></h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其他节点，确保数据安全，这个叫做故障转移。</p>
<h1 id="初始Sentinel"><a href="#初始Sentinel" class="headerlink" title="初始Sentinel"></a>初始Sentinel<br></h1><h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题<br></h2><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505419.png" alt="[Pasted image 20231031141724.png]"><br>解决雪崩问题的常见方式有四种：</p>
<ul>
<li>超时处理：设定超过时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505766.png" alt="[Pasted image 20231031141923.png]"></li>
<li>舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051505350.png" alt="[Pasted image 20231031142252.png]"></li>
<li>熔断降级模式：由断路器统计业务执行的异常比例，如果超过阈值则会熔断该业务，拦截访问该业务的一切请求<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506316.png" alt="[Pasted image 20231031142614.png]"></li>
<li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506640.png" alt="[Pasted image 20231031142831.png]"></li>
</ul>
<h2 id="服务保护技术对比"><a href="#服务保护技术对比" class="headerlink" title="服务保护技术对比"></a>服务保护技术对比<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506449.png" alt="[Pasted image 20231031143324.png]"></p>
<h2 id="认识Sentinel"><a href="#认识Sentinel" class="headerlink" title="认识Sentinel"></a>认识Sentinel<br></h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：(<a target="_blank" rel="noopener" href="http://sentinelguard.io/zh-cn/index.html">http://sentinelguard.io/zh-cn/index.html</a>)<br>Sentinel具有以下特征：</p>
<ul>
<li>丰富的应用场景：Sentinel承接了阿里巴巴近10年的双十一大促场景的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等</li>
<li>完备的实时监控：Sentinel同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至500台以下规模的集群的汇总运行情况。</li>
<li>广泛的开源生态：Sentinel提供开箱即用的与其它开源框架&#x2F;库的整合模块,例如与Spring Cloud、Dobbo、gRPC的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入Sentinel</li>
<li>完善的SPI扩展点：Sentinel提供简单易用、完善的SPI扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等</li>
</ul>
<h2 id="安装Sentinel控制台"><a href="#安装Sentinel控制台" class="headerlink" title="安装Sentinel控制台"></a>安装Sentinel控制台<br></h2><p>sentinel官方提供了UI控制台，方便我们对系统做限流设置。大家可以在GitHub下载。课前资料提供了下载好的jar包：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506756.png" alt="[Pasted image 20231031150131.png]"></p>
<ol>
<li>将其拷贝到一个你能记住的非中文目录，然后运行命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure></li>
<li>然后访问：localhost:8080即可看到控制台页面，默认的账户和密码都是sentinel</li>
</ol>
<ul>
<li><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506045.png" alt="[Pasted image 20231031151239.png]"><br>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506275.png" alt="[Pasted image 20231031151606.png]"><br>举例说明：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar -Dserver.port=8090</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="引入cloud-demo"><a href="#引入cloud-demo" class="headerlink" title="引入cloud-demo"></a>引入cloud-demo<br></h2><p>要使用Sentinel肯定要结合微服务，这里我们使用SpringCloud实用篇中的cloud-demo工程。没有的小伙伴可以在课前资料中找到：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506152.png" alt="[Pasted image 20231031152117.png]"><br>项目结构如下：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051506833.png" alt="[Pasted image 20231031152137.png]"></p>
<h2 id="微服务整合Sentinel"><a href="#微服务整合Sentinel" class="headerlink" title="微服务整合Sentinel"></a>微服务整合Sentinel<br></h2><p>我们在order-service中整合Sentinel，并且连接Sentinel的控制台，步骤如下：</p>
<ol>
<li>引入sentinel依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置控制台地址：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure></li>
<li>访问微服务的任意端点，触发sentinel监控</li>
</ol>
<h1 id="限流规则"><a href="#限流规则" class="headerlink" title="限流规则"></a>限流规则<br></h1><h2 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路<br></h2><p>簇点链路：就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点(Endpoint)，<br>因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源<br>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507527.png" alt="[Pasted image 20231031155557.png]"></p>
<h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门<br></h2><p>点击资源&#x2F;order&#x2F;{orderId}后面的流控按钮，就可以弹出表单。表单中可以添加流控规则，如下图所示：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507247.png" alt="[Pasted image 20231031160002.png]"><br>其含义是限制&#x2F;order&#x2F;{orderId}这个资源的单击QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。</p>
<h2 id="流控规则入门案例"><a href="#流控规则入门案例" class="headerlink" title="流控规则入门案例"></a>流控规则入门案例<br></h2><p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置流控规则，QPS不能超过5。然后利用jemeter测试</p>
<ol>
<li>设置流控规则：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507158.png" alt="[Pasted image 20231031161410.png]"></li>
<li>jemeter测试：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507585.png" alt="[Pasted image 20231031161432.png]"></li>
</ol>
<h2 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式<br></h2><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p>
<ul>
<li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li>
<li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li>
<li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507564.png" alt="[Pasted image 20231031161902.png]"></li>
</ul>
<h2 id="流控模式-关联"><a href="#流控模式-关联" class="headerlink" title="流控模式-关联"></a>流控模式-关联<br></h2><ul>
<li>关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li>
<li>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051507744.png" alt="[Pasted image 20231031162600.png]"><br>当&#x2F;write资源访问量触发阈值时，就会对&#x2F;read资源限流，避免影响&#x2F;write资源</li>
</ul>
<h2 id="案例-流控模式-关联"><a href="#案例-流控模式-关联" class="headerlink" title="案例-流控模式-关联"></a>案例-流控模式-关联<br></h2><p>需求：</p>
<ul>
<li>在OrderController新建两个端点：&#x2F;order&#x2F;query和&#x2F;order.update，无序实现业务</li>
<li>配置流控规则，当&#x2F;order&#x2F;update资源被访问的QPS超过5时，对&#x2F;order&#x2F;query请求限流<br>小结：<br>满足下面条件可以使用关联模式：<ul>
<li>两个有竞争关系的资源</li>
<li>一个优先级较高，一个优先级较低</li>
</ul>
</li>
</ul>
<h2 id="流控模式-链路"><a href="#流控模式-链路" class="headerlink" title="流控模式-链路"></a>流控模式-链路<br></h2><p>链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值<br>例如有两条请求链路：</p>
<ul>
<li>&#x2F;test1 -&gt; &#x2F;common</li>
<li>&#x2F;test2 -&gt; &#x2F;common<br>如果只希望统计从&#x2F;test2进入到&#x2F;common的请求，则可以这样配置：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051508163.png" alt="[Pasted image 20231031163902.png]"></li>
</ul>
<h2 id="案例-流控模式-链路"><a href="#案例-流控模式-链路" class="headerlink" title="案例-流控模式-链路"></a>案例-流控模式-链路<br></h2><p>需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流<br>步骤：</p>
<ol>
<li>在OrderService中添加一个queryGoods方法，不用实现业务</li>
<li>在OrderController中，改造&#x2F;order&#x2F;query端点，调用OrderService中的queryGoods方法</li>
<li>在OrderController中添加一个&#x2F;order&#x2F;save的端点，调用OrderService的queryGoods方法</li>
<li>给queryGoods设置限流规则，从&#x2F;order&#x2F;query进入queryGoods的方法限制QPS必须小于2</li>
</ol>
<ul>
<li>Sentinel默认只标记Controller中的方法为资源，如果要标记其他方法，需要利用@SentinelResource注解，示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效，需要修改application.yml，添加配置:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果<br></h2><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p>
<ul>
<li>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式</li>
<li>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</li>
<li>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051508132.png" alt="[Pasted image 20231031170426.png]"></li>
</ul>
<h2 id="流控效果-warm-up"><a href="#流控效果-warm-up" class="headerlink" title="流控效果-warm up"></a>流控效果-warm up<br></h2><p>warm up也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是threshold&#x2F; coldFactor，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3<br>例如，我设置QPS的threshold为10，预热时间为5秒，那么初始阈值就是10&#x2F;3，也就是3，然后在5秒后逐渐增长到10<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051508590.png" alt="[Pasted image 20231031171135.png]"></p>
<h2 id="流控效果-排队等待"><a href="#流控效果-排队等待" class="headerlink" title="流控效果-排队等待"></a>流控效果-排队等待<br></h2><p>当请求超过QPS阈值时，快速失败和warm up会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝<br>例如：QPS&#x3D;5，意味着每200ms处理一个队列中的请求；timeout&#x3D;2000，意味着预期等待超过2000ms的请求会被拒绝并抛出异常<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051508115.png" alt="[Pasted image 20231031172315.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509647.png" alt="[Pasted image 20231031172336.png]"></p>
<h2 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流<br></h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509076.png" alt="[Pasted image 20231031173040.png]"><br>配置示例：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509371.png" alt="[Pasted image 20231031173105.png]"><br>代表的含义是：对hot这个资源的0号参数（第一个参数)做统计，每1秒相同参数值的请求数不能超过5<br>在热点参数限流的高级选项中，可以对部分参数设置例外配置：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509625.png" alt="[Pasted image 20231031173349.png]"><br>结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数额的QPS不能超过5，有两个例外：</p>
<ul>
<li>如果参数值是100，则每1秒允许的QPS为10</li>
<li>如果参数值是101，则每1秒允许的QPS为15</li>
</ul>
<h1 id="隔离和降级"><a href="#隔离和降级" class="headerlink" title="隔离和降级"></a>隔离和降级<br></h1><p>虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其他原因而故障。而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了<br>不管是线程隔离还是熔断降级，都是对<strong>客户端（调用方）</strong> 的保护<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509295.png" alt="[Pasted image 20231101083846.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509593.png" alt="[Pasted image 20231101083941.png]"></p>
<h2 id="Feign整合Sentinel"><a href="#Feign整合Sentinel" class="headerlink" title="Feign整合Sentinel"></a>Feign整合Sentinel<br></h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel</p>
<ol>
<li>修改OrderService的application.yml文件，开启Feign的Sentinel功能<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的Sentinel功能</span></span><br></pre></td></tr></table></figure></li>
<li>给FeignClient编写失败后的降级逻辑<ol>
<li>方式一：FallbackClass，无法对远程调用的异常做处理</li>
<li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种<br> 步骤一：在feign-api项目中定义类，实现FallbackFactory：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;UserClient&gt;&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> UserClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">	  <span class="comment">//创建UserClient接口实现类，实现其中的方法，编写失败降级的处理逻辑</span></span><br><span class="line">	  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClient</span>()&#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">	      <span class="comment">//记录异常信息</span></span><br><span class="line">	      <span class="type">long</span>.error(<span class="string">&quot;查询用户失败&quot;</span>,throwable);</span><br><span class="line">	      <span class="comment">//根据业务需求返回默认的数据，这里是空用户</span></span><br><span class="line">	      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤二：在feign-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserClientFallbackFactory <span class="title function_">userClientFallback</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
步骤三：在feign-api项目中的UserClient接口中使用UserClientFallbackFactory：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;,fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">	User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离<br></h2><p>线程隔离有两种方式实现：</p>
<ul>
<li>线程池隔离</li>
<li>信号量隔离（Sentinel默认采用）<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509768.png" alt="[Pasted image 20231101092513.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509143.png" alt="[Pasted image 20231101092916.png]"></li>
</ul>
<h2 id="线程隔离-舱壁模式"><a href="#线程隔离-舱壁模式" class="headerlink" title="线程隔离(舱壁模式)"></a>线程隔离(舱壁模式)<br></h2><p>在添加限流规则时，可以选择两种阈值类型：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051509995.png" alt="[Pasted image 20231101093034.png]"></p>
<ul>
<li>QPS：就是每秒的请求数，在快速入门已经演示过</li>
<li>线程数：是该资源能使用用的tomcat线程数的最大数。也就是通过限制线程数量，实现舱壁模式</li>
</ul>
<h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级<br></h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问呢该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求</p>
<h2 id="熔断降级-慢调用"><a href="#熔断降级-慢调用" class="headerlink" title="熔断降级-慢调用"></a>熔断降级-慢调用<br></h2><p>断路器熔断策略有三种：慢调用、异常比例、异常数</p>
<ul>
<li>慢调用：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510716.png" alt="[Pasted image 20231101094238.png]"><br>解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，方形一次请求做测试</li>
</ul>
<h2 id="熔断策略-异常比例、异常数"><a href="#熔断策略-异常比例、异常数" class="headerlink" title="熔断策略-异常比例、异常数"></a>熔断策略-异常比例、异常数<br></h2><p>断路器熔断策略有三种：慢调用、异常比例或异常数</p>
<ul>
<li>异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。例如：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510386.png" alt="[Pasted image 20231101095223.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510481.png" alt="[Pasted image 20231101095436.png]"><br>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。</li>
</ul>
<h1 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则<br></h1><h2 id="授权规则-1"><a href="#授权规则-1" class="headerlink" title="授权规则"></a>授权规则<br></h2><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式</p>
<ul>
<li>白名单：来源（origin）在白名单内的调用者允许访问</li>
<li>黑名单：来源（origin）在黑名单内的调用者不允许访问<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510143.png" alt="[Pasted image 20231101100507.png]"><br>例如，我们限定只允许从网关来的请求访问order-service，那么流控应用中就填写网关的名称<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510969.png" alt="[Pasted image 20231101100605.png]"><br>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestOriginParser</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
例如，我们尝试从request中获取一个名为origin的请求头，作为origin的值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isEmpty(origin))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;blank&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> origin;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们还需要在gateway服务中，利用网关的过滤器添加名为gateway的origin头：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span> <span class="comment"># 添加名为origin的请求头，值为gateway </span></span><br></pre></td></tr></table></figure>
给&#x2F;order&#x2F;{orderId}配置授权规则：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510719.png" alt="[Pasted image 20231101102129.png]"></li>
</ul>
<h2 id="自定义异常结果"><a href="#自定义异常结果" class="headerlink" title="自定义异常结果"></a>自定义异常结果<br></h2><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockExceptionHandler</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理请求被限流、降级，授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request,HttpServletResponse response,BlockException e)</span><span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而BlockException包含很多个子类，分别对应不同的场景：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051510226.png" alt="[Pasted image 20231101105753.png]"><br>我们在order-service中定义类，实现BlockExceptionHandler接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">BlockExceptionHandler</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;未知异常&quot;</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">429</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;  </span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;  </span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;  </span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;  </span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;  </span><br><span class="line">            status = <span class="number">401</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);  </span><br><span class="line">        response.setStatus(status);  </span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化<br></h1><h2 id="规则管理模式"><a href="#规则管理模式" class="headerlink" title="规则管理模式"></a>规则管理模式<br></h2><p>Sentinel的控制台规则管理有三种模式：</p>
<ul>
<li>原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失</li>
<li>pull模式</li>
<li>push模式</li>
</ul>
<h2 id="规则管理模式-pull模式"><a href="#规则管理模式-pull模式" class="headerlink" title="规则管理模式-pull模式"></a>规则管理模式-pull模式<br></h2><p>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511289.png" alt="[Pasted image 20231101140540.png]"></p>
<h2 id="规则管理模式-push模式"><a href="#规则管理模式-push模式" class="headerlink" title="规则管理模式-push模式"></a>规则管理模式-push模式<br></h2><p>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511894.png" alt="[Pasted image 20231101140918.png]"></p>
<h2 id="实现push模式"><a href="#实现push模式" class="headerlink" title="实现push模式"></a>实现push模式<br></h2><p>push模式实现最为复杂，依赖于nacos，并且需要修改Sentinel控制台源码<br>详细步骤可以参考课前资料的[[sentinel规则持久化]]</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务<br></h1><h2 id="事务的ACID原则"><a href="#事务的ACID原则" class="headerlink" title="事务的ACID原则"></a>事务的ACID原则<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511200.png" alt="[Pasted image 20231101142537.png]"></p>
<h2 id="分布式服务案例"><a href="#分布式服务案例" class="headerlink" title="分布式服务案例"></a>分布式服务案例<br></h2><p>微服务下单业务，在下单时会调用订单服务，创建订单并写入数据库。然后订单服务调用账户服务和库存服务：</p>
<ul>
<li>账户服务负责扣减用户余额</li>
<li>库存服务负责扣减商品库存<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511573.png" alt="[Pasted image 20231101142834.png]"></li>
</ul>
<h2 id="分布式服务的事务问题"><a href="#分布式服务的事务问题" class="headerlink" title="分布式服务的事务问题"></a>分布式服务的事务问题<br></h2><p>在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一直，这样的事务就是分布式事务<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511714.png" alt="[Pasted image 20231101145459.png]"></p>
<h1 id="分布式服务理论基础"><a href="#分布式服务理论基础" class="headerlink" title="分布式服务理论基础"></a>分布式服务理论基础<br></h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理<br></h2><p>1998年，加州大学的计算机科学家Eric Brewer提出，分布式系统有三个指标：</p>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance（分区容错性）<br>Eric Brewer说，分布式系统无法同时满足这三个指标。<br>这个结论叫做CAP定理<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511629.png" alt="[Pasted image 20231101151431.png]"></li>
</ul>
<h2 id="CAP定理-Consistency"><a href="#CAP定理-Consistency" class="headerlink" title="CAP定理-Consistency"></a>CAP定理-Consistency<br></h2><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051511215.png" alt="[Pasted image 20231101151640.png]"></p>
<h2 id="CAP定理-Availability"><a href="#CAP定理-Availability" class="headerlink" title="CAP定理-Availability"></a>CAP定理-Availability<br></h2><p>Availability（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512757.png" alt="[Pasted image 20231101151949.png]"></p>
<h2 id="CAP定理-Partition-tolerance"><a href="#CAP定理-Partition-tolerance" class="headerlink" title="CAP定理-Partition tolerance"></a>CAP定理-Partition tolerance<br></h2><p>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区<br>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512845.png" alt="[Pasted image 20231101152256.png]"></p>
<h2 id="CAP总结"><a href="#CAP总结" class="headerlink" title="CAP总结"></a>CAP总结<br></h2><p>简述CAP定理内容？</p>
<ul>
<li>分布式系统节点通过网络连接，一定会出现分区问题（P）</li>
<li>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足<br>思考：elasticsearch集群是CP还是AP？</li>
<li>ES集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其他节点，保证数据一致。因此是低可用性，高一致性，属于CP</li>
</ul>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论<br></h2><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>Basically Avaliable（基本可用）：分布式系统在出现故障时，允许损失部分可用性，既保证核心可用</li>
<li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致<br>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：</li>
<li>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致</li>
<li>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态</li>
</ul>
<h2 id="分布式事务模型"><a href="#分布式事务模型" class="headerlink" title="分布式事务模型"></a>分布式事务模型<br></h2><p>解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）<br>这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512454.png" alt="[Pasted image 20231101161538.png]"></p>
<h1 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a>初识Seata<br></h1><p>Seata是2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案<br>官网地址：(<a target="_blank" rel="noopener" href="http://seata.io/)%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E6%92%AD%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">http://seata.io/)，其中的文档、播客中提供了大量的使用说明、源码分析</a></p>
<h2 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构<br></h2><p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li>TC（Transaction Coordinator）- 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚</li>
<li>TM（Transaction Manager）- 事务管理者：定义全局事务的范围、开始全局事务、提交或回滚全局事务</li>
<li>RM（Resource Manager）- 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚<br>![[Pasted image 20231102083542.png]]</li>
</ul>
<h2 id="初识Seata-1"><a href="#初识Seata-1" class="headerlink" title="初识Seata"></a>初识Seata<br></h2><p>Seata提供了四种不同的分布式事务解决方案：</p>
<ul>
<li>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li>TCC模式：最终一直的分阶段事务模式，有业务侵入</li>
<li>AT模式：最终一直的分阶段事务模式，无业务侵入，也是Seata的默认模式</li>
<li>SAGA模式：长事务模式，有业务侵入</li>
</ul>
<h2 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务<br></h2><p>参考课前资料提供的文档[[seata的部署和集成]]</p>
<h2 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata<br></h2><ol>
<li>首先，引入seata相关依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>        <span class="comment">&lt;!--版本较低,1.3.0，因此排除--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>然后，配置application.yml，让微服务通过注册中心找到seata-tc-server：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span>  </span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址  </span></span><br><span class="line">    <span class="comment"># 参考tc服务自己的registry.conf中的配置  </span></span><br><span class="line">    <span class="comment"># 包括：地址、namespace、group、application-name、cluster  </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span>  </span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment"># tc  </span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  </span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span>  </span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span>  </span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># tc服务在nacos中的服务名称  </span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span>  </span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span>  </span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组，根据这个获取tc服务的cluster名称  </span></span><br><span class="line">  <span class="attr">service:</span>  </span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与TC服务cluster的映射关系  </span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践<br></h1><h2 id="XA模式原理"><a href="#XA模式原理" class="headerlink" title="XA模式原理"></a>XA模式原理<br></h2><p>XA规范是 x&#x2F;Open组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA规范描述了全局的TM与局部的RM之前的接口，几乎所有主流的数据库都对XA规范提供了支持<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512864.png" alt="[Pasted image 20231102100552.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512958.png" alt="[Pasted image 20231102100635.png]"></p>
<h2 id="seata的XA模式"><a href="#seata的XA模式" class="headerlink" title="seata的XA模式"></a>seata的XA模式<br></h2><p>seata的XA模式做了一些调整，但大体相似：<br>RM一阶段的工作：</p>
<ol>
<li>注册分支事务到TC</li>
<li>执行分支事务sql但不提交</li>
<li>报告执行状态到TC<br>TC二阶段的工作：</li>
</ol>
<ul>
<li>TC检测各分支事务执行状态<ul>
<li>如果都失败，通知所有RM提交事务</li>
<li>如果有失败，通知所有RM回滚事务<br>  RM二阶段的工作：</li>
</ul>
</li>
<li>接收TC指令，提交或回滚事务<br>![[Pasted image 20231102101010.png]]</li>
</ul>
<h2 id="实现XA模式"><a href="#实现XA模式" class="headerlink" title="实现XA模式"></a>实现XA模式<br></h2><p>Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：</p>
<ol>
<li>修改application.yml文件（每个参与事务的微服务），开启XA模式：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span> <span class="comment"># 开启数据源代理的XA模式</span></span><br></pre></td></tr></table></figure></li>
<li>给发起全局事务的入口方法添加@GlobalTransactional注解，本例中是OrderServiceImpl中的create方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">create</span><span class="params">(Order order)</span>&#123;</span><br><span class="line">	<span class="comment">//创建订单</span></span><br><span class="line">	orderMapper.insert(order);</span><br><span class="line">	<span class="comment">//扣余额 ...略</span></span><br><span class="line">	<span class="comment">//扣减库存 ...略</span></span><br><span class="line">	<span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启服务并测试</li>
</ol>
<h2 id="AT模式原理"><a href="#AT模式原理" class="headerlink" title="AT模式原理"></a>AT模式原理<br></h2><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷<br>阶段一RM的工作：</p>
<ul>
<li>记录分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态<br>阶段二提交时RM的工作：</li>
<li>删除undo-log即可<br>阶段二回滚时RM的工作：</li>
<li>根据undo-log恢复数据到更新前<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512950.png" alt="[Pasted image 20231102103856.png]"><br>例如，一个分支业务的SQL是这样的：update tb_account set money &#x3D; money - 10 where id &#x3D; 1<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051512177.png" alt="[Pasted image 20231102104301.png]"><br>总结：<br>简述AT模式与XA模式最大的区别是什么？</li>
<li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源</li>
<li>XA模式以来数据库机制实现回滚；AT模式利用数据快照实现数据回滚</li>
<li>XA模式情义值；AT模式最终一致</li>
</ul>
<h2 id="AT模式的脏写问题"><a href="#AT模式的脏写问题" class="headerlink" title="AT模式的脏写问题"></a>AT模式的脏写问题<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513602.png" alt="[Pasted image 20231102105008.png]"></p>
<h2 id="AT模式的写隔离"><a href="#AT模式的写隔离" class="headerlink" title="AT模式的写隔离"></a>AT模式的写隔离<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513638.png" alt="[Pasted image 20231102105313.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513552.png" alt="[Pasted image 20231102105655.png]"></p>
<h2 id="AT模式的优缺点"><a href="#AT模式的优缺点" class="headerlink" title="AT模式的优缺点"></a>AT模式的优缺点<br></h2><p>AT模式的优点:</p>
<ul>
<li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li>
<li>利用全局锁实现读写隔离</li>
<li>没有代码侵入，框架自动完成回滚和提交<br>AT模式的缺点：</li>
<li>两阶段之间属于软状态，属于最终一致</li>
<li>框架的快照功能回影响性能，但比XA模式要好很多</li>
</ul>
<h2 id="实现AT模式"><a href="#实现AT模式" class="headerlink" title="实现AT模式"></a>实现AT模式<br></h2><p>AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单</p>
<ol>
<li>导入课前资料提供的Sql文件：seata-at.sql，其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库:</li>
<li>修改application.yml文件，将事务模式修改为AT模式即可:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 开启数据源代理的AT模式</span></span><br></pre></td></tr></table></figure></li>
<li>重启服务并测试</li>
</ol>
<h2 id="TCC模式原理"><a href="#TCC模式原理" class="headerlink" title="TCC模式原理"></a>TCC模式原理<br></h2><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p>
<ul>
<li>Try：资源的检测和预留；</li>
<li>Confirm：完成资源操作业务；要求Try成功Confirm一定要能成功</li>
<li>Cancel：预留资源释放，可以理解为try的反向操作<br>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需求余额扣减30元</li>
<li>阶段一（Try）：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513507.png" alt="[Pasted image 20231102112601.png]"></li>
<li>阶段二：加入要提交（Confirm），则冻结金额扣减30<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513152.png" alt="[Pasted image 20231102112612.png]"></li>
<li>阶段二：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513764.png" alt="[Pasted image 20231102112619.png]"><br>TCC的工作模型图：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513913.png" alt="[Pasted image 20231102112850.png]"><br>总结：<br>TCC模式的每个阶段是做什么的？</li>
<li>Try：资源检查和预留</li>
<li>Confirm：业务执行和提交</li>
<li>Cancel：预留资源的释放<br>TCC的优点是什么？</li>
<li>一阶段完成直接提交事务，释放数据库资源，性能好</li>
<li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li>
<li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库<br>TCC的缺点是什么？</li>
<li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li>
<li>软状态，事务是最终一致</li>
<li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li>
</ul>
<h2 id="TCC的空回滚和业务悬挂"><a href="#TCC的空回滚和业务悬挂" class="headerlink" title="TCC的空回滚和业务悬挂"></a>TCC的空回滚和业务悬挂<br></h2><p>当某分支事务的try阶段阻塞时，可能导致全局事务而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051513310.png" alt="[Pasted image 20231102114713.png]"><br>对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂</p>
<h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析<br></h2><p>为了实现空回滚、防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务id和执行状态，为此我们设计了一张表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#x27;account_freeze_tbl&#x27;(</span><br><span class="line">  &#x27;xid&#x27; varchar(128) NOT NULL,</span><br><span class="line">  &#x27;user_id&#x27;varchar(255) DEFAULT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  &#x27;freeze_money&#x27; int(11) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;冻结金额&#x27;,</span><br><span class="line">  &#x27;state&#x27; int(1) DEFAULT NULL COMMENT &#x27;事务状态,0:try,1:confirm,2:cancel&#x27;,</span><br><span class="line">  PRIMARY KEY(&#x27;xid&#x27;) USING BTREE </span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</span><br></pre></td></tr></table></figure>
<p>Try业务:</p>
<ul>
<li>记录冻结金额和事务状态到account_freeze表</li>
<li>扣减account表可用金融<br>Confirm业务：</li>
<li>根据xid删除account_freeze表的冻结记录<br>Cancel业务：</li>
<li>修改account_freeze表，冻结金额为0，state为2</li>
<li>修改account表，恢复可用金额<br>如何判断是否空回滚：</li>
<li>cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚<br>如何避免业务悬挂：</li>
<li>try业务中，根据xid查询account_freeze，如果已经存在则证明Cancel已经执行，拒绝执行try业务</li>
</ul>
<h2 id="声明TCC接口"><a href="#声明TCC接口" class="headerlink" title="声明TCC接口"></a>声明TCC接口<br></h2><p>TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TCCService</span>&#123;</span><br><span class="line">	<span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  Try逻辑，<span class="doctag">@TwoPhaseBusinessAction</span>中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId 用户id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money 金额  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;,commitMethod = &quot;confirm&quot;,rollbackMethod = &quot;cancel&quot;)</span>  </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,  </span></span><br><span class="line"><span class="params">            <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span> <span class="type">int</span> money)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 二阶段confirm确认方法，可以另命名，但要保证与commitMethod一致  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 上下文，可以传递try方法的参数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean 执行是否成功  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext context)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 二阶段回滚方法，要保证与rollbackMethod一致  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 上下文，可以传递try方法的参数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean 执行是否成功  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式<br></h2><p>Saga模式是SEATA提供的长事务解决方案。也分为两个阶段：</p>
<ul>
<li>一阶段：直接提交本地事务</li>
<li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051514124.png" alt="[Pasted image 20231102151514.png]"><br>Saga模式优点：</li>
<li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li>
<li>一阶段直接提交事务，无锁，性能好</li>
<li>不用编写TCC中的三个阶段，实现简单<br>缺点：</li>
<li>软状态持续时间不确定，时效性差</li>
<li>没有锁，没有事务隔离，会有脏写</li>
</ul>
<h2 id="四种模式对比"><a href="#四种模式对比" class="headerlink" title="四种模式对比"></a>四种模式对比<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051514199.png" alt="[Pasted image 20231102152039.png]"></p>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用<br></h1><h2 id="TC的异地多机房容灾架构"><a href="#TC的异地多机房容灾架构" class="headerlink" title="TC的异地多机房容灾架构"></a>TC的异地多机房容灾架构<br></h2><p>TC服务作为Seata的核心服务，一定要保证高可用和异地容灾。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515286.png" alt="[Pasted image 20231102152905.png]"><br>具体实现请参考<a href="seata%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E9%9B%86%E6%88%90">[seata的部署和集成]</a></p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化<br></h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB<br></h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。<br>快照文件被称为RDB文件，默认是保存在当前运行目录。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515271.png" alt="[Pasted image 20231103090039.png]"><br>Redis停机时会执行一次RDB。<br>首先需要在Linux系统中安装一个Redis，如果尚未安装的同学，可以参考[[Redis集群]]<br>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515845.png" alt="[Pasted image 20231103093930.png]"><br>RDB的其他配置也可以在redis.conf文件中设置:<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515696.png" alt="[Pasted image 20231103094032.png]"><br>bgsave开始时会fork主进程得到子进程,子进程共享主进程的内存数据.完成fork后读取内存数据并写入RDB文件。<br>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作<br>![[Pasted image 20231103102410.png]]<br>总结：<br>RDB方式bgsave的基本流程？</li>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件<br>RDB会在什么时候执行？save 60 1000代表什么含义？</li>
<li>默认是服务停止时。</li>
<li>代表60秒内至少执行1000次修改则触发RDB<br>RDB的缺点？</li>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RED文件都比较耗时</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF<br></h2><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515346.png" alt="[Pasted image 20231103104057.png]"><br>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051515091.png" alt="[Pasted image 20231103104422.png]"><br>AOP的命令记录的频率也可以通过redis.conf文件来配:<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516635.png" alt="[Pasted image 20231103104526.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516198.png" alt="[Pasted image 20231103105212.png]"><br>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录会对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516008.png" alt="[Pasted image 20231103113103.png]"><br>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516592.png" alt="[Pasted image 20231103113204.png]"><br>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516651.png" alt="[Pasted image 20231103113936.png]"></p>
<h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从<br></h1><h2 id="搭建主从架构"><a href="#搭建主从架构" class="headerlink" title="搭建主从架构"></a>搭建主从架构<br></h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516039.png" alt="[Pasted image 20231103115733.png]"><br>具体搭建流程参考[[Redis集群]]</p>
<h2 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理<br></h2><p>主从第一次同步是全量同步：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516704.png" alt="[Pasted image 20231103154205.png]"><br>master如何判断slave是不是第一次来同步数据？这里会用到两个很重要的概念：</p>
<ul>
<li>Replication id：简称replid，是数据集的标记，id一直则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>
<li>offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051516447.png" alt="[Pasted image 20231103162029.png]"><br>主从第一次同步是全量同步，但如果slave重启后同步，则执行增量同步<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517354.png" alt="[Pasted image 20231103164254.png]"><br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517275.png" alt="[Pasted image 20231103164317.png]"><br>可以从以下几个方面来优化Redis主从就集群：</li>
<li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过都磁盘IO</li>
<li>适当提高repl_backlog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517291.png" alt="[Pasted image 20231103170314.png]"></li>
</ul>
<h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵<br></h1><h2 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用<br></h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<ul>
<li>监控：Sentinel会不断检查你的master和slave是否按预期工作</li>
<li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li>
<li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517609.png" alt="[Pasted image 20231104083630.png]"></li>
</ul>
<h2 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控<br></h2><p>Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线</li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517466.png" alt="[Pasted image 20231104084244.png]"></li>
</ul>
<h2 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master<br></h2><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li>首先会判断salve节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds*10）则会排除该slave节点</li>
<li>然后判断slave节点的slave-priority，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<h2 id="如何实现故障转移"><a href="#如何实现故障转移" class="headerlink" title="如何实现故障转移"></a>如何实现故障转移<br></h2><p>当选中了其中一个slave为新的master后（例如slave1），故障的转移的步骤如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li>
<li>sentinel给所有其它slave发送slaveof 192.168.140.131 7002命令，让这些slave成为新master的从节点，开始从新的master上同步数据</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051517688.png" alt="[Pasted image 20231104085831.png]"></li>
</ul>
<h2 id="搭建哨兵架构"><a href="#搭建哨兵架构" class="headerlink" title="搭建哨兵架构"></a>搭建哨兵架构<br></h2><p>具体搭建流程参考<a href="Redis%E9%9B%86%E7%BE%A4">[Redis集群]</a></p>
<h2 id="RedisTemplate的哨兵模式"><a href="#RedisTemplate的哨兵模式" class="headerlink" title="RedisTemplate的哨兵模式"></a>RedisTemplate的哨兵模式<br></h2><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换<br>首先，引入课前资料提供的Demo工程：redis-demo</p>
<ol>
<li>在pom文件中引入redis的starter依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>然后在配置文件application.yml中指定sentinel相关信息：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">redis:</span>  </span><br><span class="line">    <span class="attr">sentinel:</span>  </span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment"># 指定master名称  </span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="comment"># 指定redis-sentinel集群信息  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:27001</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:27002</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:27003</span></span><br></pre></td></tr></table></figure></li>
<li>配置主从读写分离<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的ReadFrom是配置Redis的读取策略，是一个枚举，包括下面选择：</li>
</ol>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li>REPLICA_PREFERRED：优先从slave(replica)节点读取，所有的slave都不可用才读取master</li>
</ul>
<h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群<br></h1><h2 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构<br></h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题<br>使用分片集群可以解决上述问题，分片集群特征：</li>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051518930.png" alt="[Pasted image 20231104101128.png]"></li>
</ul>
<h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群<br></h2><p>具体搭建流程参考<a href="Redis%E9%9B%86%E7%BE%A4">[Redis集群]</a></p>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽<br></h2><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051521885.png" alt="[Pasted image 20231104102453.png]"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li>key中包含”{}”，且”{}”中至少包含1个字符，”{}”中的部分是有效部分</li>
<li>key中不包含”{}”，整个key都是有效部分<br>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051521490.png" alt="[Pasted image 20231104103640.png]"></li>
</ul>
<h2 id="添加一个节点到集群"><a href="#添加一个节点到集群" class="headerlink" title="添加一个节点到集群"></a>添加一个节点到集群<br></h2><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051521253.png" alt="[Pasted image 20231104104219.png]"><br>比如，添加节点的命令：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051521390.png" alt="[Pasted image 20231104104245.png]"></p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移<br></h2><p>当集群中有一个master宕机会发生什么呢？</p>
<ol>
<li>首先是该实例与其它实例失去连接</li>
<li>然后是疑似宕机<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051521997.png" alt="[Pasted image 20231104141707.png]"></li>
<li>最后是确定下线，自动提升一个slave为新的master：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051522888.png" alt="[Pasted image 20231104141756.png]"></li>
</ol>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移<br></h2><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：<br>手动的Failover支持三种不同模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6步</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<h2 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群<br></h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<ol>
<li>引入redis的starter依赖</li>
<li>配置分片集群地址</li>
<li>配置读写分离<br>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">redis:</span>  </span><br><span class="line">    <span class="attr">cluster:</span>    </span><br><span class="line">      <span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息  </span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:7001</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:7002</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:8003</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存<br></h1><h2 id="传统缓存的问题"><a href="#传统缓存的问题" class="headerlink" title="传统缓存的问题"></a>传统缓存的问题<br></h2><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在下面的问题：</p>
<ul>
<li>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</li>
<li>Redis缓存失效时，会对数据库产生冲击<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051522945.png" alt="[Pasted image 20231104145400.png]"></li>
</ul>
<h2 id="多级缓存方案"><a href="#多级缓存方案" class="headerlink" title="多级缓存方案"></a>多级缓存方案<br></h2><p>多级缓存就是充分利用请求处理的每个环节，分贝添加缓存，减轻Tomcat压力，提升服务性能：<br>![[Pasted image 20231104145648.png]](Pasted image 20231104145648.png)<br>用作缓存的Nginx是业务Nginx，需要部署为集群，再有专门的Nginx用来做反向代理：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051522796.png" alt="[Pasted image 20231104150742.png]"></p>
<h1 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存<br></h1><h2 id="导入商品案例"><a href="#导入商品案例" class="headerlink" title="导入商品案例"></a>导入商品案例<br></h2><p>参考课前资料提供的文档来导入案例:[[案例导入说明]]</p>
<h2 id="本地进程缓存"><a href="#本地进程缓存" class="headerlink" title="本地进程缓存"></a>本地进程缓存<br></h2><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p>
<ul>
<li>分布式缓存，例如Redis：<ul>
<li>优点：存储容量更大、可靠性更好、可以在集群间共享</li>
<li>缺点：访问缓存有网络开销</li>
<li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li>
</ul>
</li>
<li>进程本地缓存，例如HashMap、GuavaCache：<ul>
<li>优点：读取本地内存，没有网络开销，速度更快</li>
<li>缺点：存储容量有限、可靠性较低、无法共享</li>
<li>场景：性能要求较高，缓存数据量较小<br>  Caffeine是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffrine。GitHub地址：(<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffrine">https://github.com/ben-manes/caffrine</a>)<br>  <img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051522951.png" alt="[Pasted image 20231104163349.png]"></li>
</ul>
</li>
</ul>
<h2 id="Caffeine示例"><a href="#Caffeine示例" class="headerlink" title="Caffeine示例"></a>Caffeine示例<br></h2><p>可以通过item-service项目中的单元测试来学习Caffeine的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBasicOps</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//创建缓存对象</span></span><br><span class="line">	Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line">	<span class="comment">//存数据</span></span><br><span class="line">	cache.put(<span class="string">&quot;gf&quot;</span>，<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">	<span class="comment">//取数据，不存在则返回null</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">gf</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;gf&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;gf=&quot;</span> + gf);</span><br><span class="line">	<span class="comment">//取数据，不存在则去数据库查询</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">defaultGF</span> <span class="operator">=</span> cache.get(<span class="string">&quot;defaultGF&quot;</span>,key -&gt; &#123;</span><br><span class="line">		<span class="comment">//这里可以去数据库根据 key查询value</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;柳岩&quot;</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	System.out.println(<span class="string">&quot;defaultGF =&quot;</span> + defaultGF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<ul>
<li>基于容量：设置缓存的数量上限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建混存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">		.maximumSize(<span class="number">1</span>) <span class="comment">// 设置缓存大小上限为1</span></span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure></li>
<li>基于时间：设置缓存的有效时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建缓存对象</span></span><br><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">		<span class="comment">//设置缓存有效期为 10 秒，从最后一次写入开始计时</span></span><br><span class="line">		.expireAfterWrite(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">		.builder();</span><br></pre></td></tr></table></figure></li>
<li>基于引用：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。<br>在默认情况下，当一个缓存元素过期的时候。Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐</li>
</ul>
<h1 id="Lua语法入门"><a href="#Lua语法入门" class="headerlink" title="Lua语法入门"></a>Lua语法入门<br></h1><h2 id="初始Lua"><a href="#初始Lua" class="headerlink" title="初始Lua"></a>初始Lua<br></h2><p>Lua是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，其设计目的就是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：(<a target="_blank" rel="noopener" href="https://www.lua.org/">https://www.lua.org/</a>)<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051523609.png" alt="[Pasted image 20231105084319.png]"></p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld<br></h2><ol>
<li>在linux虚拟机的任意目录下，新建一个hello.lua文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> hello.lua</span><br></pre></td></tr></table></figure></li>
<li>添加下面的内容<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>运行<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua hello.lua</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051523141.png" alt="[Pasted image 20231105085132.png]"><br>可以利用type函数测试给定变量或者值的类型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;Hello World&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量<br></h2><p>Lua声明变量的时候，并不需要指定数据类型：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明字符串</span></span><br><span class="line"><span class="keyword">local</span> str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">-- 声明数字</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">21</span></span><br><span class="line"><span class="comment">-- 声明布尔类型</span></span><br><span class="line"><span class="keyword">local</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 声明table，类似java的map</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>,age=<span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure>
<p>访问table：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 访问数组，lua数组的角标从1开始</span></span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 访问table</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(map.name)</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环<br></h2><p>数组、table都可以利用for循环来遍历：</p>
<ul>
<li>遍历数组：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明数组 key为索引的 table</span></span><br><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;lua&#x27;</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历数据</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(index,value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>遍历table：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明map，也就是table</span></span><br><span class="line"><span class="keyword">local</span> map = &#123;name=<span class="string">&#x27;Jack&#x27;</span>,age=<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">-- 遍历table</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(map) <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">print</span>(key,value)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数<br></h2><p>定义函数的语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名<span class="params">(argument1, argument2..., argumentn)</span></span></span><br><span class="line">	<span class="comment">-- 函数体</span></span><br><span class="line">	<span class="keyword">return</span> 返回值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>例如，定义一个函数，用来打印数组：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArr</span><span class="params">(arr)</span></span></span><br><span class="line">	<span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">		<span class="built_in">print</span>(value)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>		</span><br></pre></td></tr></table></figure>
<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制<br></h2><p>类似Java的条件控制，例如if、else语法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="comment">-- [布尔表达式为 true 时执行该语句块]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment">-- [布尔表达式为 false 时执行该语句块]</span></span><br><span class="line"><span class="keyword">end</span>	</span><br></pre></td></tr></table></figure>
<p>与java不同，布尔表达式中的逻辑运算是基于英文单词：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051523417.png" alt="[Pasted image 20231105092924.png]"></p>
<h1 id="多级缓存-1"><a href="#多级缓存-1" class="headerlink" title="多级缓存"></a>多级缓存<br></h1><h2 id="初识OpenResty"><a href="#初识OpenResty" class="headerlink" title="初识OpenResty"></a>初识OpenResty<br></h2><p>OpenResty是一个基于Nginx的高性能Web平台，用来方便地搭建能够处理超高并发、扩展性极高的动态Web应用、Web服务和动态网关。具备下列特点：</p>
<ul>
<li>具备Nginx的完整功能</li>
<li>基于Lua语言进行扩展，集成了大量精良的Lua库、第三方模块</li>
<li>允许Lua自定义业务逻辑、自定义库<br>官方网站：(<a target="_blank" rel="noopener" href="https://openresty.org/cn/">https://openresty.org/cn/</a>)<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051523441.png" alt="[Pasted image 20231105093633.png]"><br>安装OpenResty可以参考[[安装OpenResty]]</li>
</ul>
<h2 id="案例：OpenResty快速入门，实现商品详情页数据查询"><a href="#案例：OpenResty快速入门，实现商品详情页数据查询" class="headerlink" title="案例：OpenResty快速入门，实现商品详情页数据查询"></a>案例：OpenResty快速入门，实现商品详情页数据查询<br></h2><p>商品详情页面目前展示的是假数据，在浏览器的控制台可以看到查询商品信息的请求：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051523544.png" alt="[Pasted image 20231105095257.png]"><br>而这个请求最终被反向代理到虚拟机的OpenResty集群：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524815.png" alt="[Pasted image 20231105095334.png]"><br>需求：在OpenResty中接收这个请求，并返回一段商品的假数据。</p>
<h2 id="步骤一：修改nginx-conf文件"><a href="#步骤一：修改nginx-conf文件" class="headerlink" title="步骤一：修改nginx.conf文件"></a>步骤一：修改nginx.conf文件<br></h2><ol>
<li>在nginx.conf的http下面，添加对OpenResty的Lua模块的加载：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载lua 模块</span></span><br><span class="line"><span class="attribute">lua_package_path</span> <span class="string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;</span><br><span class="line"><span class="comment"># 加载c模块</span></span><br><span class="line"><span class="attribute">lua_package_cpath</span> <span class="string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>在nginx.conf的server下面，添加对&#x2F;api&#x2F;item这个路径的监听：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/item</span><br><span class="line">	<span class="comment"># 响应类型，这里返回json</span></span><br><span class="line">	default_type application/json;</span><br><span class="line">	<span class="comment"># 响应数据由 lua/item.lua这个文件来决定</span></span><br><span class="line">	<span class="attribute">content_by_lua_file</span> lua/item.lua;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="步骤二：编写item-lua文件"><a href="#步骤二：编写item-lua文件" class="headerlink" title="步骤二：编写item.lua文件"></a>步骤二：编写item.lua文件<br></h2><ol>
<li>在nginx目录创建文件夹：lua<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524832.png" alt="[Pasted image 20231105100905.png]"></li>
<li>在lua文件夹下，新建文件：item.lua<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524749.png" alt="[Pasted image 20231105100934.png]"></li>
<li>内容如下：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 返回假数据，这里的ngx.say()函数，就是写数据到Response中</span></span><br><span class="line">ngx.say(<span class="string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>重新加载配置<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="OpenResty获取请求参数"><a href="#OpenResty获取请求参数" class="headerlink" title="OpenResty获取请求参数"></a>OpenResty获取请求参数<br></h2><p>OpenResty提供了各种API用来获取不同类型的请求参数：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524594.png" alt="[Pasted image 20231105102151.png]"></p>
<h2 id="多级缓存需求"><a href="#多级缓存需求" class="headerlink" title="多级缓存需求"></a>多级缓存需求<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524349.png" alt="[Pasted image 20231105103009.png]"></p>
<h2 id="nginx内部发送Http请求"><a href="#nginx内部发送Http请求" class="headerlink" title="nginx内部发送Http请求"></a>nginx内部发送Http请求<br></h2><p>nginx提供了内部API用以发送http请求：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> resp = ngx.localtion.capture(<span class="string">&quot;/path&quot;</span>,&#123;</span><br><span class="line">	method = ngx.HTTP_GET, <span class="comment">-- 请求方式</span></span><br><span class="line">	args = &#123;a=<span class="number">1</span>,b=<span class="number">2</span>&#125;, <span class="comment">-- get方式传参数</span></span><br><span class="line">	body = <span class="string">&quot;c=3&amp;d=4&quot;</span> <span class="comment">-- post方式传参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>返回的响应内容包括：</p>
<ul>
<li>resp.status：响应状态码</li>
<li>resp.header：响应头，是一个table</li>
<li>resp.body：响应体，就是响应数据<br>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。<br>但是我们希望这个请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /path&#123;</span><br><span class="line">	<span class="comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span></span><br><span class="line">	<span class="attribute">proxy_pass</span> http://192.168.111.17:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="封装http查询的函数"><a href="#封装http查询的函数" class="headerlink" title="封装http查询的函数"></a>封装http查询的函数<br></h2><p>我们可以把http查询的请求封装为一个函数，放到OpenResty函数库中，方便后期使用</p>
<ol>
<li>在&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;lualib目录下创建common.lua文件：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/openresty/lualib/common.lua</span><br></pre></td></tr></table></figure></li>
<li>在common.lua中封装http查询的函数<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，发送http请求，并解析响应</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_http</span><span class="params">(path, params)</span></span></span><br><span class="line">	<span class="keyword">local</span> resp = ngx.location.capture(<span class="built_in">path</span>,&#123;</span><br><span class="line">		method = ngx.HTTP_GET,</span><br><span class="line">		args = params,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">		<span class="comment">-- 记录错误信息，返回404</span></span><br><span class="line">		ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;http not found,path:&quot;</span>, <span class="built_in">path</span> , <span class="string">&quot;,args:&quot;</span>, args)</span><br><span class="line">		ngx.<span class="built_in">exit</span>(<span class="number">404</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">return</span> resp.body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 将方法导出</span></span><br><span class="line"><span class="keyword">local</span> _M = &#123;</span><br><span class="line">	read_http = read_http</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="JSON结果处理"><a href="#JSON结果处理" class="headerlink" title="JSON结果处理"></a>JSON结果处理<br></h2><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化<br>官方地址：(<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-cjson">https://github.com/openresty/lua-cjson</a>)</p>
<ul>
<li>引入cjson模块：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">&quot;cjson&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>序列化<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = &#123;</span><br><span class="line">	name = <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">	age = <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> json = cjson.encode(obj)</span><br></pre></td></tr></table></figure></li>
<li>反序列化<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:21&#125;&#x27;</span></span><br><span class="line"><span class="comment">-- 反序列化</span></span><br><span class="line"><span class="keyword">local</span> obj = cjson.decode(json);</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Tomcat集群的负载均衡"><a href="#Tomcat集群的负载均衡" class="headerlink" title="Tomcat集群的负载均衡"></a>Tomcat集群的负载均衡<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051524759.png" alt="[Pasted image 20231105140924.png]"></p>
<h2 id="添加redis缓存的需求"><a href="#添加redis缓存的需求" class="headerlink" title="添加redis缓存的需求"></a>添加redis缓存的需求<br></h2><p><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051525528.png" alt="[Pasted image 20231105141318.png]"></p>
<h2 id="冷启动与缓存预热"><a href="#冷启动与缓存预热" class="headerlink" title="冷启动与缓存预热"></a>冷启动与缓存预热<br></h2><p>冷启动：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力<br>缓存预热：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中</p>
<p>我们数据量较少，可以在启动时将所有数据都放入缓存中</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热<br></h2><ol>
<li>利用Docker安装Redis<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -d redis redis-server --appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li>
<li>在item-service服务中引入Redis依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置Redis地址<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span></span><br></pre></td></tr></table></figure></li>
<li>编写初始化类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisHandler</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// 初始化缓存 ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="OpenResty的Redis模块"><a href="#OpenResty的Redis模块" class="headerlink" title="OpenResty的Redis模块"></a>OpenResty的Redis模块<br></h2><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用：</p>
<ul>
<li>引入Redis模块，并初始化Redis对象<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 引入redis模块</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">&quot;resty.redis&quot;</span>)</span><br><span class="line"><span class="comment">-- 初始化Redis对象</span></span><br><span class="line"><span class="keyword">local</span> red = redis::new()</span><br><span class="line"><span class="comment">-- 设置Redis超时时间</span></span><br><span class="line">red:set_timeouts(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li>
<li>封装函数，用来释放Redis连接，其实是放入连接池<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">close_redis</span><span class="params">(red)</span></span></span><br><span class="line">	 <span class="keyword">local</span> pool_max_idle_time = <span class="number">10000</span> <span class="comment">-- 连接的空闲时间，单位是毫秒</span></span><br><span class="line">	 <span class="keyword">local</span> pool_size = <span class="number">100</span> <span class="comment">--连接池大小</span></span><br><span class="line">	 <span class="keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time,pool_size)</span><br><span class="line">	 <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">		 ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;放入Redis连接池失败:&quot;</span>, err)</span><br><span class="line">	 <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>封装函数，从Redis读数据并返回<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_redis</span><span class="params">(ip, port, key)</span></span></span><br><span class="line">	<span class="comment">-- 获取一个连接</span></span><br><span class="line">	<span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">		ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;连接redis失败：&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 查询redis</span></span><br><span class="line">	<span class="keyword">local</span> resp,err = red:get(key)</span><br><span class="line">	<span class="comment">-- 查询失败处理</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></span><br><span class="line">		ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;查询Redis失败：&quot;</span>,err,<span class="string">&quot;, key = &quot;</span>, key)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 得到的数据为空处理</span></span><br><span class="line">	<span class="keyword">if</span> resp == ngx.null <span class="keyword">then</span></span><br><span class="line">		resp = <span class="literal">nil</span></span><br><span class="line">		ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;查询Redis数据为空，key = &quot;</span>, key)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	close_redis(red)</span><br><span class="line">	<span class="keyword">return</span> resp</span><br><span class="line"><span class="keyword">end</span>		</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ngxin本地缓存"><a href="#ngxin本地缓存" class="headerlink" title="ngxin本地缓存"></a>ngxin本地缓存<br></h2><p>OpenResty为Nginx提供了shard dict的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p>
<ul>
<li>开启共享字典，在nginx.conf的http下添加配置：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class="line"><span class="attribute">lua_shared_dict</span> item_cache <span class="number">150m</span>;</span><br></pre></td></tr></table></figure></li>
<li>操作共享字典：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取本地缓存对象</span></span><br><span class="line"><span class="keyword">local</span> item_cache = ngx.shared.item_cache</span><br><span class="line"><span class="comment">-- 存储，指定key、value、过期时间，单位s，默认为0代表永不过期</span></span><br><span class="line">item_cache:set(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">-- 读取</span></span><br><span class="line"><span class="keyword">local</span> val = item_cache:get(<span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>
修改后的查询逻辑：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装函数，先查询本地缓存，在查询redis，在查询http</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">read_data</span><span class="params">(key, expire,path,params)</span></span></span><br><span class="line">	<span class="comment">-- 读取本地缓存</span></span><br><span class="line">	<span class="keyword">local</span> val = item_cache:get(key)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">		<span class="comment">-- 缓存未命中，记录日志</span></span><br><span class="line">		ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;本地缓存查询失败，key: &quot;</span>,key,<span class="string">&quot;，尝试redis查询&quot;</span>)</span><br><span class="line">		<span class="comment">-- 查询redis</span></span><br><span class="line">		val = read_redis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>,key)</span><br><span class="line">		<span class="comment">-- 判断redis是否命中</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> val <span class="keyword">then</span></span><br><span class="line">			ngx.<span class="built_in">log</span>(ngx.ERR,<span class="string">&quot;Redis缓存查询失败,key&quot;</span>,key,<span class="string">&quot;，尝试http查询&quot;</span>)</span><br><span class="line">		<span class="comment">-- Redis查询失败，查询http</span></span><br><span class="line">		val = read_http(<span class="built_in">path</span>, params)</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="comment">-- 写入本地缓存</span></span><br><span class="line">	item_cache:set(key,val,expire)</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 根据id查询商品</span></span><br><span class="line"><span class="keyword">local</span> itemJSON = read_data(<span class="string">&#x27;item:id&#x27;</span> .. id,<span class="number">1800</span>,<span class="string">&quot;/item/&quot;</span>.. id,<span class="literal">nil</span>)</span><br><span class="line"><span class="comment">-- 根据id查询商品库存</span></span><br><span class="line"><span class="keyword">local</span> itemStockJSON = read_data(<span class="string">&#x27;item:stock:id&#x27;</span> .. id,<span class="number">60</span>,<span class="string">&quot;/item/stock/&quot;</span>.. id,<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步<br></h1><h2 id="缓存同步策略"><a href="#缓存同步策略" class="headerlink" title="缓存同步策略"></a>缓存同步策略<br></h2><p>缓存数据同步的常见方式有三种：</p>
<ul>
<li>设置有效期：给缓存设置有效期，到期后自动删除。再次查询时更新<ul>
<li>优势：简单、方便</li>
<li>缺点：时效性差，缓存过期之前可能不一致</li>
<li>场景：更新频率较低，时效性要求低的业务</li>
</ul>
</li>
<li>同步双写：在修改数据库的同时，直接修改缓存<ul>
<li>优势：时效性强，缓存与数据库强一致</li>
<li>缺点：有代码侵入，耦合度高；</li>
<li>场景：对一致性、时效性要求较高的缓存数据</li>
</ul>
</li>
<li>异步通知：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据<ul>
<li>优势：低耦合，可以同时通知多个缓存服务</li>
<li>缺点：时效性一般，可能存在中间不一致状态</li>
<li>场景：时效性要求一般，有多个服务需要同步<br>  基于MQ的异步通知：<br>  <img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051525772.png" alt="[Pasted image 20231106093510.png]"><br>  基于Canal的异步通知：<br>  <img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051525540.png" alt="[Pasted image 20231106093544.png]"></li>
</ul>
</li>
</ul>
<h2 id="初识Canal"><a href="#初识Canal" class="headerlink" title="初识Canal"></a>初识Canal<br></h2><p><strong>Canal</strong>，译意为水管&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。GitHub的地址：(<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a>)<br>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p>
<ul>
<li>MySQL master将数据变更写入二进制日志（binary log）,其中记录的数据叫做binary log events</li>
<li>MySQL slave将master的binary log events拷贝到它的中继日志（relay log）</li>
<li>MySQL slave重放relay log中事件，将数据变更反映它自己的数据<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051525224.png" alt="[Pasted image 20231106095841.png]"><br>Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051525966.png" alt="[Pasted image 20231106100021.png]"></li>
</ul>
<h2 id="安装和配置Canal"><a href="#安装和配置Canal" class="headerlink" title="安装和配置Canal"></a>安装和配置Canal<br></h2><p>安装和配置Canal参考<a href="%E5%AE%89%E8%A3%85Canal">[安装Canal]</a></p>
<h2 id="Canal客户端"><a href="#Canal客户端" class="headerlink" title="Canal客户端"></a>Canal客户端<br></h2><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526761.png" alt="[Pasted image 20231106142924.png]"><br>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。不过这里我们会使用GitHub上的第三方开源的canal-starter。地址：(<a target="_blank" rel="noopener" href="https://github.com/NormanGyllenhaal/canal-client">https://github.com/NormanGyllenhaal/canal-client</a>)<br>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- canal --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.javatool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canal:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">heima</span> <span class="comment">#canal实例名称，要跟canal-server运行时设置的destionation一致</span></span><br><span class="line">  <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:11111</span> <span class="comment"># canal地址</span></span><br></pre></td></tr></table></figure>
<p>编写监听器，监听Canal消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.item.canal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CanalTable(&quot;tb_item&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemHandler</span> <span class="keyword">implements</span> <span class="title class_">EntryHandler</span>&lt;Item&gt; &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">		<span class="comment">//新增数据到redis</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Item before,Item after)</span>&#123;</span><br><span class="line">		<span class="comment">// 更新redis数据</span></span><br><span class="line">		<span class="comment">//更新本地缓存</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Item item)</span>&#123;</span><br><span class="line">		<span class="comment">//删除redis数据</span></span><br><span class="line">		<span class="comment">//清理本地缓存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Canal推送给canal-client的是被修改的这一行数据（row），而我们引入的canal-client则会帮我们把行数据封装到Item实体类中。这个过程中需要知道数据库与实体的映射关系，要用到JPA的几个注解：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526107.png" alt="[Pasted image 20231106144512.png]"></p>
<h1 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性<br></h1><h2 id="消息可靠性问题"><a href="#消息可靠性问题" class="headerlink" title="消息可靠性问题"></a>消息可靠性问题<br></h2><p>消息从生产者发送到exchange，再到queue，再到消费者，有哪些导致消息丢失的可能性？</p>
<ul>
<li>发送时丢失：<ul>
<li>生产者发送的消息未送达exchange</li>
<li>消息到达exchange后未到达queue</li>
</ul>
</li>
<li>MQ宕机，queue将消息丢失</li>
<li>consumer接收到消息后未消费就宕机<br>![[Pasted image 20231106145924.png]]</li>
</ul>
<h2 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制<br></h2><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。结果有两种请求：</p>
<ul>
<li>publisher-confirm，发送者确认<ul>
<li>消息成功投递到交换机，返回ack</li>
<li>消息未投递到交换机，返回nack</li>
</ul>
</li>
<li>publisher-return，发送者回执<ul>
<li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因</li>
</ul>
</li>
</ul>
<h2 id="SpringAMQP实现生产者确认"><a href="#SpringAMQP实现生产者确认" class="headerlink" title="SpringAMQP实现生产者确认"></a>SpringAMQP实现生产者确认<br></h2><ol>
<li>在publisher这个微服务的application.yml中添加配置:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
配置说明：</li>
</ol>
<ul>
<li>publish-confirm-type：开启publisher-confirm，这里支持两种类型：<ul>
<li>simple：同步等待confirm结果，直到超时</li>
<li>correlated：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li>
</ul>
</li>
<li>publish-returns：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</li>
<li>template.mandatory：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</li>
</ul>
<ol start="2">
<li>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目启动过程中配置：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="comment">// 获取RabbitTemplate</span></span><br><span class="line">		<span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> applicationContext.getBean(RabbitTemplate.class);</span><br><span class="line">		<span class="comment">//设置ReturnCallback</span></span><br><span class="line">		rabbitTemplate.setReturnCallback((message, replyCode, replyText,exchange,routingKey) -&gt; &#123;</span><br><span class="line">			log.info(<span class="string">&quot;消息发送失败，应答码&#123;&#125;,原因&#123;&#125;,交换机&#123;&#125;,路由键&#123;&#125;,消息&#123;&#125;&quot;</span>,</span><br><span class="line">				replyCode, replyText, exchange, routingKey,message.toString());</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>发送消息，指定消息ID、消息ConfirmCallback<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">	<span class="comment">//消息体</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">	<span class="comment">//消息ID，需要封装到CorrelationData中</span></span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">corrlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	<span class="comment">//添加callback</span></span><br><span class="line">	correlationData.getFuture().addCallback(</span><br><span class="line">		result -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(result.isAck())&#123;</span><br><span class="line">				<span class="comment">// ack，消息成功</span></span><br><span class="line">				log.debug(<span class="string">&quot;消息发送成功，ID:&#123;&#125;&quot;</span>,correlationData.getId());</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">// nack，消息失败</span></span><br><span class="line">				log.error(<span class="string">&quot;消息发送失败，ID:&#123;&#125;，原因&#123;&#125;&quot;</span>,correlationData.getId(),result.getReason());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		ex -&gt; log.error(<span class="string">&quot;消息发送异常，ID:&#123;&#125;，原因&#123;&#125;&quot;</span>,correlationData.getId(),ex.getMessage())</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;amq.direct&quot;</span>,<span class="string">&quot;simple&quot;</span>,nessage,correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化<br></h1><p>MQ默认是内存存储消息，开启持久化功能可以确保缓存在MQ中的消息不丢失。</p>
<ol>
<li>交换机持久化：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>队列持久化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消息持久化，SpringAMQP中的消息默认是持久的，可以通过MessageProperties中的DeliveryMode来指定的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">		.withBody(message.getBytes(StandardCharsets.UTF_8)) <span class="comment">// 消息体</span></span><br><span class="line">		.setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="comment">//持久化</span></span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认<br></h2><p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息<br>而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li>manual：手动ack，需要在业务代码结束后，调用api发送ack。</li>
<li>auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack<br>配置方式是修改application.yml文件，添加下面配置：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># none，关闭ack;manual，手动ack;auto;自动ack</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制<br></h2><p>当消费者出现异常后，消息会不断requeue(重新入队)到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526210.png" alt="[Pasted image 20231106164342.png]"><br>我们可以利用Spirng的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 下次失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="string">max-attempts：3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态;false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>
<h2 id="消费者失败消息处理策略"><a href="#消费者失败消息处理策略" class="headerlink" title="消费者失败消息处理策略"></a>消费者失败消息处理策略<br></h2><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</li>
<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</li>
<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526028.png" alt="[Pasted image 20231106170243.png]"><br>测试下RepublishMessageRecoverer处理模式：</li>
<li>首先，定义接收失败消息的交换机、队列及其绑定关系：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorMessageExchange()).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后，定义RepublishMessageRecoverer：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate,<span class="string">&quot;error.direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结<br></h2><p>如何确保RabbitMQ消息的可靠性？</p>
<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息未消费前在队列中不会丢失</li>
<li>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li>
<li>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li>
</ul>
<h1 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机<br></h1><h2 id="初识死信交换机"><a href="#初识死信交换机" class="headerlink" title="初识死信交换机"></a>初识死信交换机<br></h2><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p>
<ul>
<li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的Requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息推挤满了，最早的消息可能成为死信<br>如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机（Dead Letter Exchange，简称DLX）。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526931.png" alt="[Pasted image 20231107084027.png]"></li>
</ul>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL<br></h2><p>TTL，也就是Time-To-Live。如果一个队列中的消息TTL仍未消费，则会变为死信，ttl超时分为两种情况：</p>
<ul>
<li>消息所在的队列设置了存活时间</li>
<li>消息本身设置了存活时间<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051526890.png" alt="[Pasted image 20231107084546.png]"><br>我们声明一组死信交换机和队列，基于注解方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">		value = @Queue(name = &quot;dl.queue&quot;,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">		exchange = @Exchange(name = &quot;dl.direct&quot;),</span></span><br><span class="line"><span class="meta">		key = &quot;dl&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 dl.queue的延迟消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要给队列设置超时时间，需要在声明队列时配置x-message-ttl属性：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;ttl.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;ttl.queue&quot;</span>) <span class="comment">//指定队列名称，并持久化</span></span><br><span class="line">			.ttl(<span class="number">10000</span>) <span class="comment">//设置队列的超时时间，10秒</span></span><br><span class="line">			.deadLetterExchange(<span class="string">&quot;dl.direct&quot;</span>) <span class="comment">//指定死信交换机</span></span><br><span class="line">			.deadLetterRoutingKey(<span class="string">&quot;dl&quot;</span>) <span class="comment">// 指定死信RoutingKey</span></span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">simpleBinding</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="string">&quot;ttl&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
发送消息时，给消息本身设置超时时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTTLMsg</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//创建消息</span></span><br><span class="line">	<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">			.withBody(<span class="string">&quot;hello,ttl message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">			.setExpiration(<span class="string">&quot;5000&quot;</span>)</span><br><span class="line">			.build();</span><br><span class="line">	<span class="comment">//消息ID，需要封装到CorrelationData中</span></span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	<span class="comment">//发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;ttl.direct&quot;</span>,<span class="string">&quot;ttl&quot;</span>,message,correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列<br></h2><p>利用TTL结合死信交换机，我们实现了消息发出后，消息者延迟收到消息的效果。这种消息模式被称为延迟队列（Delay Queue）模式。<br>延迟队列的使用场景包括：</p>
<ul>
<li>延迟发送短信</li>
<li>用户下单，如果用户在15分钟内未支付，则自动取消</li>
<li>预约工作会议，20分钟后自动通知所有参会人员</li>
</ul>
<h2 id="延迟队列插件"><a href="#延迟队列插件" class="headerlink" title="延迟队列插件"></a>延迟队列插件<br></h2><p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。<br>详细安装过程参考<a href="RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97">[RabbitMQ部署指南]</a></p>
<h2 id="SpringAMQP使用延迟队列插件"><a href="#SpringAMQP使用延迟队列插件" class="headerlink" title="SpringAMQP使用延迟队列插件"></a>SpringAMQP使用延迟队列插件<br></h2><p>DelayExchange的本质还是官方的三种交换机，只是添加了延迟功能。因此使用时只需要声明一个交换机，交换机的类型可以是任意类型，然后设定delayed属性为true即可。<br>基于注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">		value = @Queue(name = &quot;delay.queue&quot;,durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">		exchange = @Exchange(name = &quot;delay.direct&quot;,delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">		key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayedQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 delay.queue的延迟消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于java代码的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ExhcangeBuilder</span><br><span class="line">			.directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">			.delayed() <span class="comment">//设置delay属性为true</span></span><br><span class="line">			.durable(<span class="literal">true</span>) <span class="comment">//持久化</span></span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">delayedBinding</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(delayedQueue().to(delayedExchange()).with(<span class="string">&quot;delay&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们向这个delay为true的交换机中发送消息，一定要给消息添加一个header: x-delay，值为延迟的时间，单位为毫秒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelayedMsg</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 创建消息</span></span><br><span class="line">	<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder</span><br><span class="line">			.withBody(<span class="string">&quot;hello,delayde message&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">			.setHeader(<span class="string">&quot;x-delay&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">			.builder();</span><br><span class="line">	<span class="comment">// 消息ID，需要封装到CorrelationData中</span></span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	<span class="comment">// 发送消息</span></span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>,<span class="string">&quot;delay&quot;</span>,message,correlationData);</span><br><span class="line">	log.debug(<span class="string">&quot;发送消息成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列<br></h1><h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题<br></h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。最早接收的消息，可能就会成为死信，会被丢弃，这就是消息堆积问题。<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051527107.png" alt="[Pasted image 20231107113320.png]"><br>解决消息堆积有三种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h2 id="惰性队列-1"><a href="#惰性队列-1" class="headerlink" title="惰性队列"></a>惰性队列<br></h2><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的概念，也就是惰性队列。<br>惰性队列的特征如下：</p>
<ul>
<li>接收到消息后直接存到磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储<br>而要设置一个惰性队列，只需要在声明队列时，指定x-queue-mode属性为lazy即可。可以通过命令行将一个运行中的队列修改为惰性队列：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>
用SpringAMQP声明惰性队列分两种方式：</li>
<li>@Bean的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder</span><br><span class="line">			.durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">			.lazy() <span class="comment">// 开启x-queue-mode为lazy</span></span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注解方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">		name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">		durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">		arguments = @Argument(name = &quot;x-queue-mode&quot;,value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">	log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="MQ集群"><a href="#MQ集群" class="headerlink" title="MQ集群"></a>MQ集群</h1><h2 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类<br></h2><p>RabbitMQ的是基于Erlang语言编写，而Erlang又是一个面向并发的语言，天然支持集群模式。RabbitMQ的集群有两种模式：</p>
<ul>
<li>普通集群：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力</li>
<li>镜像集群：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性<br>镜像集群虽然支持主从，但主从同步并不不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：仲裁队列来代替镜像集群，底层采用Raft协议确保主从的数据一致性。</li>
</ul>
<h2 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群<br></h2><p>普通集群，或者叫标准集群（classic cluster），具备下列特征：</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051527331.png" alt="[Pasted image 20231107151616.png]"><br>详细的搭建步骤参考<a href="RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97">[RabbitMQ部署指南]</a></li>
</ul>
<h2 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群<br></h2><p>镜像集群：本质是主从模式，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的主节点，备份到的其他节点叫做该队列的镜像节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主<br><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="https://cdn.jsdelivr.net/gh/879x/Drawingbed/img/202403051527127.png" alt="[Pasted image 20231107154652.png]"><br>详细的搭建步骤可以参考<a href="RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97">[RabbitMQ部署指南]</a></li>
</ul>
<h2 id="仲裁队列"><a href="#仲裁队列" class="headerlink" title="仲裁队列"></a>仲裁队列<br></h2><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于Raft协议，强一致<br>详细的搭建步骤可以参考：[[RabbitMQ部署指南]]<br>SpringAMQP创建仲裁队列：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">quorumQueue</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> QueueBuilder</span><br><span class="line">			.durable(<span class="string">&quot;quorum.queue&quot;</span>) <span class="comment">// 持久化</span></span><br><span class="line">			.quorum() <span class="comment">// 仲裁队列</span></span><br><span class="line">			.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
SpringAMQP连接集群，只需要在yaml中配置即可：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.131</span><span class="string">:8071,192.168.140.131:8072,192.168.140.131:8073</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">huanji</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://879x.github.io">幻季</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://879x.github.io/2024/03/05/Spring%20Cloud/">https://879x.github.io/2024/03/05/Spring%20Cloud/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://879x.github.io" target="_blank">幻季的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/img/Amashiro.Natsuki.full.2856783.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331190850.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331190850.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331190906.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240331190906.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/03/Java%20%E8%A1%A5%E5%9F%BA%E7%A1%80/" title="java 基础"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-p22lwj.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java 基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/07/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="权限管理"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-lm6wjl_1920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">权限管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/19/Java%20%E4%BD%BF%E7%94%A8thumbnailator%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/" title="Java 使用thumbnailator进行图片处理"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-4orw89_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="title">Java 使用thumbnailator进行图片处理</div></div></a></div><div><a href="/2024/03/03/Java%20%E8%A1%A5%E5%9F%BA%E7%A1%80/" title="java 基础"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-p22lwj.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="title">java 基础</div></div></a></div><div><a href="/2024/03/28/MongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/" title="MongoDB的使用"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-lm6wjl_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">MongoDB的使用</div></div></a></div><div><a href="/2024/05/24/git%E4%BD%BF%E7%94%A8/" title="git使用"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-4orw89_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-24</div><div class="title">git使用</div></div></a></div><div><a href="/2024/03/07/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E5%92%8C%E6%94%AF%E4%BB%98%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="微信登录和支付的实现"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-lm6wjl_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-07</div><div class="title">微信登录和支付的实现</div></div></a></div><div><a href="/2024/03/07/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" title="权限管理"><img class="cover" src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-lm6wjl_1920x1080.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-07</div><div class="title">权限管理</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">幻季</div><div class="author-info__description">生命不会后退，也不在过去停留。<br/> -M·斯科特·派克- <br/></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/879x/879x.github.io"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/879x" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">幻季的个人博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">微服务远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.1.</span> <span class="toc-text">提供者和消费者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Eureka%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Eureka的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eureka%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">Eureka架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAEurekaServer"><span class="toc-number">2.3.</span> <span class="toc-text">搭建EurekaServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8Cuser-service"><span class="toc-number">2.4.</span> <span class="toc-text">注册user-service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96"><span class="toc-number">2.5.</span> <span class="toc-text">服务拉取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8order-service%E5%AE%8C%E6%88%90%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">在order-service完成服务拉取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.6.</span> <span class="toc-text">Ribbon负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">负载均衡流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">2.6.2.</span> <span class="toc-text">负载均衡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.6.3.</span> <span class="toc-text">饥饿加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.</span> <span class="toc-text">Nacos注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%88%B0Nacos"><span class="toc-number">3.1.</span> <span class="toc-text">服务注册到Nacos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">服务集群属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">根据集群负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%9D%83%E9%87%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.4.</span> <span class="toc-text">根据权重负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB-namespace"><span class="toc-number">3.5.</span> <span class="toc-text">环境隔离-namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90"><span class="toc-number">3.6.</span> <span class="toc-text">nacos注册中心细节分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AE%9E%E4%BE%8B%E5%92%8C%E9%9D%9E%E4%B8%B4%E6%97%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.7.</span> <span class="toc-text">临时实例和非临时实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Nacos配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">统一配置管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0"><span class="toc-number">4.2.</span> <span class="toc-text">配置自动刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">4.3.</span> <span class="toc-text">多环境配置共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">4.4.</span> <span class="toc-text">Nacos集群搭建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%AE%A2%E6%88%B7%E7%AB%AFFeign"><span class="toc-number">5.</span> <span class="toc-text">http客户端Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E6%9B%BF%E6%8D%A2RestTemplate"><span class="toc-number">5.1.</span> <span class="toc-text">Feign替换RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RestTemplate%E6%96%B9%E5%BC%8F%E8%B0%83%E7%94%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.1.</span> <span class="toc-text">RestTemplate方式调用存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.2.</span> <span class="toc-text">Feign的介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8Feign%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.2.</span> <span class="toc-text">定义和使用Feign客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Feign%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">5.3.</span> <span class="toc-text">自定义Feign的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">Feign的性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE"><span class="toc-number">5.4.1.</span> <span class="toc-text">Feign的性能优化-连接池配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fegin%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.5.</span> <span class="toc-text">Fegin的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96FeignClient"><span class="toc-number">5.6.</span> <span class="toc-text">抽取FeignClient</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%BD%91%E5%85%B3Gateway"><span class="toc-number">6.</span> <span class="toc-text">统一网关Gateway</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3"><span class="toc-number">6.1.</span> <span class="toc-text">为什么需要网关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">网关的技术实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1"><span class="toc-number">6.3.</span> <span class="toc-text">搭建网关服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82Route-Predicate-Factoy"><span class="toc-number">6.4.</span> <span class="toc-text">路由断言工厂Route Predicate Factoy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8-GatewayFilter"><span class="toc-number">6.5.</span> <span class="toc-text">路由过滤器 GatewayFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82-GatewayFilterFactory"><span class="toc-number">6.6.</span> <span class="toc-text">过滤器工厂 GatewayFilterFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%BB%99%E6%89%80%E6%9C%89%E8%BF%9B%E5%85%A5userservice%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">6.7.</span> <span class="toc-text">案例：给所有进入userservice的请求添加一个请求头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">6.7.1.</span> <span class="toc-text">默认过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8-GlobalFilter"><span class="toc-number">6.8.</span> <span class="toc-text">全局过滤器 GlobalFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.9.</span> <span class="toc-text">过滤器执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-number">6.10.</span> <span class="toc-text">跨域问题处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8BDocker"><span class="toc-number">7.</span> <span class="toc-text">初始Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">项目部署的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker"><span class="toc-number">7.2.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.3.</span> <span class="toc-text">Docker与虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">镜像和容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%92%8CDockerHub"><span class="toc-number">7.5.</span> <span class="toc-text">Docker和DockerHub</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E6%9E%B6%E6%9E%84"><span class="toc-number">7.6.</span> <span class="toc-text">docker架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">Docker基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">8.1.</span> <span class="toc-text">镜像相关命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">镜像操作命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BB%8EDockerHub%E4%B8%AD%E6%8B%89%E5%8F%96%E4%B8%80%E4%B8%AAnginx%E9%95%9C%E5%83%8F%E5%B9%B6%E6%9F%A5%E7%9C%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">案例：从DockerHub中拉取一个nginx镜像并查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8docker-save%E5%B0%86nginx%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E7%A3%81%E7%9B%98%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E9%80%9A%E8%BF%87load%E5%8A%A0%E8%BD%BD%E5%9B%9E%E6%9D%A5"><span class="toc-number">8.2.2.</span> <span class="toc-text">案例：利用docker save将nginx镜像导出磁盘，然后在通过load加载回来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">镜像操作有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">8.3.</span> <span class="toc-text">容器相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8"><span class="toc-number">8.3.1.</span> <span class="toc-text">案例：创建运行一个nginx容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BF%9B%E5%85%A5Nginx%E5%AE%B9%E5%99%A8%EF%BC%8C%E4%BF%AE%E6%94%B9HTML%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E6%B7%BB%E5%8A%A0%E2%80%9CHello%E2%80%9D"><span class="toc-number">8.3.2.</span> <span class="toc-text">案例：进入Nginx容器，修改HTML文件内容，添加“Hello”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">8.4.</span> <span class="toc-text">数据卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">8.5.</span> <span class="toc-text">操作数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%8C%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%9C%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.5.1.</span> <span class="toc-text">创建一个数据卷，并查看数据卷在宿主机的目录位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">8.6.</span> <span class="toc-text">挂载数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84html%E7%9B%AE%E5%BD%95%E5%86%85%E7%9A%84index-html%E5%86%85%E5%AE%B9"><span class="toc-number">8.6.1.</span> <span class="toc-text">创建一个nginx容器，修改容器内的html目录内的index.html内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAMySQL%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%B0%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD%E5%88%B0%E5%AE%B9%E5%99%A8"><span class="toc-number">8.6.2.</span> <span class="toc-text">创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">8.6.3.</span> <span class="toc-text">数据卷挂载的方式对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dcokerfile%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">9.</span> <span class="toc-text">Dcokerfile自定义镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">镜像结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDockerfile"><span class="toc-number">9.2.</span> <span class="toc-text">什么是Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DockerCompose"><span class="toc-number">10.</span> <span class="toc-text">DockerCompose</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDockerCompose"><span class="toc-number">10.1.</span> <span class="toc-text">什么是DockerCompose</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">11.</span> <span class="toc-text">Docker镜像仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.1.</span> <span class="toc-text">常见镜像仓库服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E6%88%96%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">11.2.</span> <span class="toc-text">在私有镜像仓库推送或拉取镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86MQ"><span class="toc-number">12.</span> <span class="toc-text">初识MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">12.1.</span> <span class="toc-text">同步通讯和异步通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.</span> <span class="toc-text">同步调用的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-number">12.3.</span> <span class="toc-text">异步调用方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E4%BC%98%E5%8A%BF"><span class="toc-number">12.4.</span> <span class="toc-text">事件驱动优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">12.5.</span> <span class="toc-text">异步通信的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMQ"><span class="toc-number">12.6.</span> <span class="toc-text">什么是MQ</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">13.</span> <span class="toc-text">RabbitMQ快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">RabbitMQ概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.2.</span> <span class="toc-text">常见消息模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HelloWorld%E6%A1%88%E4%BE%8B"><span class="toc-number">13.3.</span> <span class="toc-text">HelloWorld案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E5%AE%98%E6%96%B9Demo%E4%B8%AD%E7%9A%84hello-world%E6%A1%88%E4%BE%8B"><span class="toc-number">13.4.</span> <span class="toc-text">完成官方Demo中的hello world案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringAMQP"><span class="toc-number">14.</span> <span class="toc-text">SpringAMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88SpringAMQP"><span class="toc-number">14.1.</span> <span class="toc-text">什么SpringAMQP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SpringAMQP%E5%AE%9E%E7%8E%B0HelloWorld%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8A%9F%E8%83%BD"><span class="toc-number">14.2.</span> <span class="toc-text">利用SpringAMQP实现HelloWorld中的基础消息队列功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Work-Queue%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-number">14.3.</span> <span class="toc-text">Work Queue工作队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FWorkQueue%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">14.4.</span> <span class="toc-text">模拟WorkQueue，实现一个队列绑定多个消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%A2%84%E5%8F%96%E9%99%90%E5%88%B6"><span class="toc-number">14.5.</span> <span class="toc-text">消费预取限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%EF%BC%88Publish%EF%BC%89%E3%80%81%E8%AE%A2%E9%98%85%EF%BC%88Subscribe%EF%BC%89"><span class="toc-number">14.6.</span> <span class="toc-text">发布（Publish）、订阅（Subscribe）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-Fanout-Exchange"><span class="toc-number">14.7.</span> <span class="toc-text">发布订阅-Fanout Exchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SpringAMQP%E6%BC%94%E7%A4%BAFanoutExchange%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.8.</span> <span class="toc-text">利用SpringAMQP演示FanoutExchange的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E8%AE%A2%E9%98%85-DirectExchange"><span class="toc-number">14.9.</span> <span class="toc-text">发送订阅-DirectExchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SpringAMQP%E6%BC%94%E7%A4%BADirectExchange%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.10.</span> <span class="toc-text">利用SpringAMQP演示DirectExchange的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85-TopicExchange"><span class="toc-number">14.11.</span> <span class="toc-text">发布订阅-TopicExchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8SpringAMQP%E6%BC%94%E7%A4%BATopicExchange%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.12.</span> <span class="toc-text">利用SpringAMQP演示TopicExchange的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringAMQP-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">SpringAMQP-消息转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%8F%91%E9%80%81Object%E7%B1%BB%E5%9E%8B%E6%B6%88%E6%81%AF"><span class="toc-number">15.1.</span> <span class="toc-text">测试发送Object类型消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">15.2.</span> <span class="toc-text">消息转换器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86elasticsearch"><span class="toc-number">16.</span> <span class="toc-text">初识elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFelasticsearch"><span class="toc-number">16.1.</span> <span class="toc-text">什么是elasticsearch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elasticsearch%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">16.2.</span> <span class="toc-text">elasticsearch的发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0elasticsearch%EF%BC%9F"><span class="toc-number">16.3.</span> <span class="toc-text">为什么学习elasticsearch？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">16.4.</span> <span class="toc-text">正向索引和倒排索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">16.5.</span> <span class="toc-text">文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88index%EF%BC%89"><span class="toc-number">16.6.</span> <span class="toc-text">索引（index）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%AF%B9%E6%AF%94"><span class="toc-number">16.7.</span> <span class="toc-text">概念对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">16.8.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85elasticsearch%E3%80%81kibana"><span class="toc-number">16.9.</span> <span class="toc-text">安装elasticsearch、kibana</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">16.10.</span> <span class="toc-text">分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ik%E5%88%86%E8%AF%8D%E5%99%A8-%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.11.</span> <span class="toc-text">ik分词器-模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ik%E5%88%86%E8%AF%8D%E5%99%A8-%E6%89%A9%E5%B1%95%E8%AF%8D%E5%BA%93"><span class="toc-number">16.12.</span> <span class="toc-text">ik分词器-扩展词库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ik%E5%88%86%E8%AF%8D%E5%99%A8-%E5%81%9C%E7%94%A8%E8%AF%8D%E5%BA%93"><span class="toc-number">16.13.</span> <span class="toc-text">ik分词器-停用词库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">17.</span> <span class="toc-text">索引库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mapping%E5%B1%9E%E6%80%A7"><span class="toc-number">17.1.</span> <span class="toc-text">mapping属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">17.2.</span> <span class="toc-text">创建索引库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">17.3.</span> <span class="toc-text">查看、删除索引库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">17.4.</span> <span class="toc-text">修改索引库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">18.</span> <span class="toc-text">文档操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3"><span class="toc-number">18.1.</span> <span class="toc-text">添加文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E3%80%81%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3"><span class="toc-number">18.2.</span> <span class="toc-text">查看、删除文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3"><span class="toc-number">18.3.</span> <span class="toc-text">修改文档</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">19.</span> <span class="toc-text">RestClient操作索引库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRestClient"><span class="toc-number">19.1.</span> <span class="toc-text">什么是RestClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8JavaRestClient%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E5%BA%93%E3%80%81%E5%88%A4%E6%96%AD%E7%B4%A2%E5%BC%95%E5%BA%93%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">19.2.</span> <span class="toc-text">利用JavaRestClient实现创建、删除索引库、判断索引库是否存在</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RestClient%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3"><span class="toc-number">20.</span> <span class="toc-text">RestClient操作文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8JavaRestClient%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E7%9A%84CRUD"><span class="toc-number">20.1.</span> <span class="toc-text">利用JavaRestClient实现文档的CRUD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8JavaRestClient%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%E9%85%92%E5%BA%97%E6%95%B0%E6%8D%AE%E5%88%B0ES"><span class="toc-number">20.2.</span> <span class="toc-text">利用JavaRestClient批量导入酒店数据到ES</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DSL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">DSL查询语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL-Query%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">21.1.</span> <span class="toc-text">DSL Query的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL-Query%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">21.2.</span> <span class="toc-text">DSL Query基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">21.3.</span> <span class="toc-text">全文检索查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">21.4.</span> <span class="toc-text">精确查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2-%E8%AF%AD%E6%B3%95"><span class="toc-number">21.5.</span> <span class="toc-text">精确查询-语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">21.6.</span> <span class="toc-text">地理查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">21.7.</span> <span class="toc-text">复合查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AE%97%E5%88%86"><span class="toc-number">21.8.</span> <span class="toc-text">相关性算分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-Score-Query"><span class="toc-number">21.9.</span> <span class="toc-text">Function Score Query</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E2%80%9C%E5%A6%82%E5%AE%B6%E2%80%9D%E8%BF%99%E4%B8%AA%E5%93%81%E7%89%8C%E7%9A%84%E9%85%92%E5%BA%97%E6%8E%92%E5%90%8D%E9%9D%A0%E5%89%8D%E4%B8%80%E7%82%B9"><span class="toc-number">21.9.1.</span> <span class="toc-text">给“如家”这个品牌的酒店排名靠前一点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2-Boolean-Query"><span class="toc-number">21.10.</span> <span class="toc-text">复合查询 Boolean Query</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8bool%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">21.10.1.</span> <span class="toc-text">利用bool查询实现功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">搜索结果处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">22.1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E9%85%92%E5%BA%97%E6%95%B0%E6%8D%AE%E6%8C%89%E7%85%A7%E5%88%B0%E4%BD%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">22.1.1.</span> <span class="toc-text">实现对酒店数据按照到你的位置坐标的距离升序排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-number">22.2.</span> <span class="toc-text">分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">22.3.</span> <span class="toc-text">深度分页问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">22.4.</span> <span class="toc-text">深度分页解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%80%BB%E7%BB%93"><span class="toc-number">22.5.</span> <span class="toc-text">分页总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E4%BA%AE"><span class="toc-number">22.6.</span> <span class="toc-text">高亮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E6%95%B4%E4%BD%93%E8%AF%AD%E6%B3%95"><span class="toc-number">22.7.</span> <span class="toc-text">搜索结果处理整体语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RestClient%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3"><span class="toc-number">23.</span> <span class="toc-text">RestClient查询文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">23.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">23.2.</span> <span class="toc-text">全文检索查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">23.3.</span> <span class="toc-text">精确查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2-boolean-query"><span class="toc-number">23.4.</span> <span class="toc-text">复合查询-boolean query</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5"><span class="toc-number">23.5.</span> <span class="toc-text">排序和分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E4%BA%AE-1"><span class="toc-number">23.6.</span> <span class="toc-text">高亮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E4%BA%AE%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90"><span class="toc-number">23.7.</span> <span class="toc-text">高亮结果解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%91%E9%A9%AC%E6%97%85%E6%B8%B8%E6%A1%88%E4%BE%8B"><span class="toc-number">24.</span> <span class="toc-text">黑马旅游案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%BB%91%E9%A9%AC%E6%97%85%E6%B8%B8%E7%9A%84%E9%85%92%E5%BA%97%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%AE%8C%E6%88%90%E5%85%B3%E9%94%AE%E5%AD%97%E6%90%9C%E7%B4%A2%E5%92%8C%E5%88%86%E9%A1%B5"><span class="toc-number">24.1.</span> <span class="toc-text">案例1：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%93%81%E7%89%8C%E3%80%81%E5%9F%8E%E5%B8%82%E3%80%81%E6%98%9F%E7%BA%A7%E3%80%81%E4%BB%B7%E6%A0%BC%E7%AD%89%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">24.2.</span> <span class="toc-text">案例2：添加品牌、城市、星级、价格等过滤功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3%EF%BC%9A%E6%88%91%E9%99%84%E8%BF%91%E7%9A%84%E9%85%92%E5%BA%97"><span class="toc-number">24.3.</span> <span class="toc-text">案例3：我附近的酒店</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E6%8E%92%E5%BA%8F"><span class="toc-number">24.3.1.</span> <span class="toc-text">距离排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4%EF%BC%9A%E8%AE%A9%E6%8C%87%E5%AE%9A%E7%9A%84%E9%85%92%E5%BA%97%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E4%B8%AD%E6%8E%92%E5%90%8D%E7%BD%AE%E9%A1%B6"><span class="toc-number">24.4.</span> <span class="toc-text">案例4：让指定的酒店在搜索结果中排名置顶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2-function-score"><span class="toc-number">24.4.1.</span> <span class="toc-text">组合查询-function score</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-number">25.</span> <span class="toc-text">数据聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">25.1.</span> <span class="toc-text">聚合的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E5%AE%9E%E7%8E%B0Bucket%E8%81%9A%E5%90%88"><span class="toc-number">25.2.</span> <span class="toc-text">DSL实现Bucket聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bucket%E8%81%9A%E5%90%88-%E8%81%9A%E5%90%88%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="toc-number">25.3.</span> <span class="toc-text">Bucket聚合-聚合结果排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bucket%E8%81%9A%E5%90%88-%E9%99%90%E5%AE%9A%E8%81%9A%E5%90%88%E8%8C%83%E5%9B%B4"><span class="toc-number">25.4.</span> <span class="toc-text">Bucket聚合-限定聚合范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL%E5%AE%9E%E7%8E%B0Metrics%E8%81%9A%E5%90%88"><span class="toc-number">25.5.</span> <span class="toc-text">DSL实现Metrics聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestAPi%E5%AE%9E%E7%8E%B0%E8%81%9A%E5%90%88"><span class="toc-number">25.6.</span> <span class="toc-text">RestAPi实现聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9C%A8IUservice%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%93%81%E7%89%8C%E3%80%81%E5%9F%8E%E5%B8%82%E3%80%81%E6%98%9F%E7%BA%A7%E7%9A%84%E8%81%9A%E5%90%88"><span class="toc-number">25.7.</span> <span class="toc-text">案例：在IUservice中定义方法，实现对品牌、城市、星级的聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%8E%A5%E5%89%8D%E7%AB%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">25.8.</span> <span class="toc-text">对接前端接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">26.</span> <span class="toc-text">自动补全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="toc-number">26.1.</span> <span class="toc-text">自动补全需求说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D"><span class="toc-number">26.2.</span> <span class="toc-text">使用拼音分词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">26.3.</span> <span class="toc-text">自定义分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completion-suggester%E6%9F%A5%E8%AF%A2"><span class="toc-number">26.4.</span> <span class="toc-text">completion suggester查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0hotel%E7%B4%A2%E5%BC%95%E5%BA%93%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E3%80%81%E6%8B%BC%E9%9F%B3%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD"><span class="toc-number">26.5.</span> <span class="toc-text">案例：实现hotel索引库的自动补全、拼音搜索功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestAPI%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">26.6.</span> <span class="toc-text">RestAPI实现自动补全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%85%92%E5%BA%97%E6%90%9C%E7%B4%A2%E9%A1%B5%E9%9D%A2%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">26.7.</span> <span class="toc-text">实现酒店搜索页面输入框的自动补全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">27.</span> <span class="toc-text">数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">27.1.</span> <span class="toc-text">数据同步问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8MQ%E5%AE%9E%E7%8E%B0mysql%E4%B8%8Eelasticearch%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">27.2.</span> <span class="toc-text">利用MQ实现mysql与elasticearch数据同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elasticsearch%E9%9B%86%E7%BE%A4"><span class="toc-number">28.</span> <span class="toc-text">elasticsearch集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">28.1.</span> <span class="toc-text">ES集群结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAES%E9%9B%86%E7%BE%A4"><span class="toc-number">28.2.</span> <span class="toc-text">搭建ES集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%9A%84%E8%8A%82%E7%82%B9%E8%A7%92%E8%89%B2"><span class="toc-number">28.3.</span> <span class="toc-text">ES集群的节点角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%9A%84%E8%84%91%E8%A3%82"><span class="toc-number">28.4.</span> <span class="toc-text">ES集群的脑裂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">28.5.</span> <span class="toc-text">ES集群的分布式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">28.6.</span> <span class="toc-text">ES集群的故障转移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8BSentinel"><span class="toc-number">29.</span> <span class="toc-text">初始Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span class="toc-number">29.1.</span> <span class="toc-text">雪崩问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">29.2.</span> <span class="toc-text">服务保护技术对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Sentinel"><span class="toc-number">29.3.</span> <span class="toc-text">认识Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Sentinel%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">29.4.</span> <span class="toc-text">安装Sentinel控制台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5cloud-demo"><span class="toc-number">29.5.</span> <span class="toc-text">引入cloud-demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">29.6.</span> <span class="toc-text">微服务整合Sentinel</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99"><span class="toc-number">30.</span> <span class="toc-text">限流规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF"><span class="toc-number">30.1.</span> <span class="toc-text">簇点链路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">30.2.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">30.3.</span> <span class="toc-text">流控规则入门案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">30.4.</span> <span class="toc-text">流控模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E5%85%B3%E8%81%94"><span class="toc-number">30.5.</span> <span class="toc-text">流控模式-关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E5%85%B3%E8%81%94"><span class="toc-number">30.6.</span> <span class="toc-text">案例-流控模式-关联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E9%93%BE%E8%B7%AF"><span class="toc-number">30.7.</span> <span class="toc-text">流控模式-链路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F-%E9%93%BE%E8%B7%AF"><span class="toc-number">30.8.</span> <span class="toc-text">案例-流控模式-链路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C"><span class="toc-number">30.9.</span> <span class="toc-text">流控效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-warm-up"><span class="toc-number">30.10.</span> <span class="toc-text">流控效果-warm up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C-%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">30.11.</span> <span class="toc-text">流控效果-排队等待</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">30.12.</span> <span class="toc-text">热点参数限流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="toc-number">31.</span> <span class="toc-text">隔离和降级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">31.1.</span> <span class="toc-text">Feign整合Sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="toc-number">31.2.</span> <span class="toc-text">线程隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB-%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">31.3.</span> <span class="toc-text">线程隔离(舱壁模式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">31.4.</span> <span class="toc-text">熔断降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7-%E6%85%A2%E8%B0%83%E7%94%A8"><span class="toc-number">31.5.</span> <span class="toc-text">熔断降级-慢调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5-%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B%E3%80%81%E5%BC%82%E5%B8%B8%E6%95%B0"><span class="toc-number">31.6.</span> <span class="toc-text">熔断策略-异常比例、异常数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">32.</span> <span class="toc-text">授权规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99-1"><span class="toc-number">32.1.</span> <span class="toc-text">授权规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C"><span class="toc-number">32.2.</span> <span class="toc-text">自定义异常结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">33.</span> <span class="toc-text">规则持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.1.</span> <span class="toc-text">规则管理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F-pull%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.2.</span> <span class="toc-text">规则管理模式-pull模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F-push%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.3.</span> <span class="toc-text">规则管理模式-push模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0push%E6%A8%A1%E5%BC%8F"><span class="toc-number">33.4.</span> <span class="toc-text">实现push模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">34.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%8E%9F%E5%88%99"><span class="toc-number">34.1.</span> <span class="toc-text">事务的ACID原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">34.2.</span> <span class="toc-text">分布式服务案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">34.3.</span> <span class="toc-text">分布式服务的事务问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">35.</span> <span class="toc-text">分布式服务理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">35.1.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86-Consistency"><span class="toc-number">35.2.</span> <span class="toc-text">CAP定理-Consistency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86-Availability"><span class="toc-number">35.3.</span> <span class="toc-text">CAP定理-Availability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86-Partition-tolerance"><span class="toc-number">35.4.</span> <span class="toc-text">CAP定理-Partition tolerance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E6%80%BB%E7%BB%93"><span class="toc-number">35.5.</span> <span class="toc-text">CAP总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-number">35.6.</span> <span class="toc-text">BASE理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">35.7.</span> <span class="toc-text">分布式事务模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Seata"><span class="toc-number">36.</span> <span class="toc-text">初识Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Seata%E6%9E%B6%E6%9E%84"><span class="toc-number">36.1.</span> <span class="toc-text">Seata架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Seata-1"><span class="toc-number">36.2.</span> <span class="toc-text">初识Seata</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2TC%E6%9C%8D%E5%8A%A1"><span class="toc-number">36.3.</span> <span class="toc-text">部署TC服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90Seata"><span class="toc-number">36.4.</span> <span class="toc-text">微服务集成Seata</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">37.</span> <span class="toc-text">动手实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XA%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">37.1.</span> <span class="toc-text">XA模式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seata%E7%9A%84XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.2.</span> <span class="toc-text">seata的XA模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.3.</span> <span class="toc-text">实现XA模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">37.4.</span> <span class="toc-text">AT模式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">37.5.</span> <span class="toc-text">AT模式的脏写问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%99%E9%9A%94%E7%A6%BB"><span class="toc-number">37.6.</span> <span class="toc-text">AT模式的写隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">37.7.</span> <span class="toc-text">AT模式的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.8.</span> <span class="toc-text">实现AT模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">37.9.</span> <span class="toc-text">TCC模式原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCC%E7%9A%84%E7%A9%BA%E5%9B%9E%E6%BB%9A%E5%92%8C%E4%B8%9A%E5%8A%A1%E6%82%AC%E6%8C%82"><span class="toc-number">37.10.</span> <span class="toc-text">TCC的空回滚和业务悬挂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90"><span class="toc-number">37.11.</span> <span class="toc-text">业务分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8ETCC%E6%8E%A5%E5%8F%A3"><span class="toc-number">37.12.</span> <span class="toc-text">声明TCC接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Saga%E6%A8%A1%E5%BC%8F"><span class="toc-number">37.13.</span> <span class="toc-text">Saga模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">37.14.</span> <span class="toc-text">四种模式对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">38.</span> <span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TC%E7%9A%84%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%9C%BA%E6%88%BF%E5%AE%B9%E7%81%BE%E6%9E%B6%E6%9E%84"><span class="toc-number">38.1.</span> <span class="toc-text">TC的异地多机房容灾架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">39.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB"><span class="toc-number">39.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF"><span class="toc-number">39.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E"><span class="toc-number">40.</span> <span class="toc-text">Redis主从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">40.1.</span> <span class="toc-text">搭建主从架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">40.2.</span> <span class="toc-text">数据同步原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="toc-number">41.</span> <span class="toc-text">Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">41.1.</span> <span class="toc-text">哨兵的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-number">41.2.</span> <span class="toc-text">服务状态监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master"><span class="toc-number">41.3.</span> <span class="toc-text">选举新的master</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">41.4.</span> <span class="toc-text">如何实现故障转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E6%9E%B6%E6%9E%84"><span class="toc-number">41.5.</span> <span class="toc-text">搭建哨兵架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisTemplate%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">41.6.</span> <span class="toc-text">RedisTemplate的哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">42.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">42.1.</span> <span class="toc-text">分片集群结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">42.2.</span> <span class="toc-text">搭建分片集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">42.3.</span> <span class="toc-text">散列插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E9%9B%86%E7%BE%A4"><span class="toc-number">42.4.</span> <span class="toc-text">添加一个节点到集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">42.5.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">42.6.</span> <span class="toc-text">数据迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">42.7.</span> <span class="toc-text">RedisTemplate访问分片集群</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">43.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">43.1.</span> <span class="toc-text">传统缓存的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="toc-number">43.2.</span> <span class="toc-text">多级缓存方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">44.</span> <span class="toc-text">JVM进程缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%95%86%E5%93%81%E6%A1%88%E4%BE%8B"><span class="toc-number">44.1.</span> <span class="toc-text">导入商品案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="toc-number">44.2.</span> <span class="toc-text">本地进程缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Caffeine%E7%A4%BA%E4%BE%8B"><span class="toc-number">44.3.</span> <span class="toc-text">Caffeine示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8"><span class="toc-number">45.</span> <span class="toc-text">Lua语法入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8BLua"><span class="toc-number">45.1.</span> <span class="toc-text">初始Lua</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HelloWorld"><span class="toc-number">45.2.</span> <span class="toc-text">HelloWorld</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">45.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">45.4.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">45.5.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">45.6.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">45.7.</span> <span class="toc-text">条件控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98-1"><span class="toc-number">46.</span> <span class="toc-text">多级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86OpenResty"><span class="toc-number">46.1.</span> <span class="toc-text">初识OpenResty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9AOpenResty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">46.2.</span> <span class="toc-text">案例：OpenResty快速入门，实现商品详情页数据查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E4%BF%AE%E6%94%B9nginx-conf%E6%96%87%E4%BB%B6"><span class="toc-number">46.3.</span> <span class="toc-text">步骤一：修改nginx.conf文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E7%BC%96%E5%86%99item-lua%E6%96%87%E4%BB%B6"><span class="toc-number">46.4.</span> <span class="toc-text">步骤二：编写item.lua文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenResty%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">46.5.</span> <span class="toc-text">OpenResty获取请求参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E9%9C%80%E6%B1%82"><span class="toc-number">46.6.</span> <span class="toc-text">多级缓存需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E5%86%85%E9%83%A8%E5%8F%91%E9%80%81Http%E8%AF%B7%E6%B1%82"><span class="toc-number">46.7.</span> <span class="toc-text">nginx内部发送Http请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85http%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">46.8.</span> <span class="toc-text">封装http查询的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">46.9.</span> <span class="toc-text">JSON结果处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E9%9B%86%E7%BE%A4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">46.10.</span> <span class="toc-text">Tomcat集群的负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0redis%E7%BC%93%E5%AD%98%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">46.11.</span> <span class="toc-text">添加redis缓存的需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">46.12.</span> <span class="toc-text">冷启动与缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">46.13.</span> <span class="toc-text">缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenResty%E7%9A%84Redis%E6%A8%A1%E5%9D%97"><span class="toc-number">46.14.</span> <span class="toc-text">OpenResty的Redis模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ngxin%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">46.15.</span> <span class="toc-text">ngxin本地缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="toc-number">47.</span> <span class="toc-text">缓存同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">47.1.</span> <span class="toc-text">缓存同步策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86Canal"><span class="toc-number">47.2.</span> <span class="toc-text">初识Canal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AECanal"><span class="toc-number">47.3.</span> <span class="toc-text">安装和配置Canal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canal%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">47.4.</span> <span class="toc-text">Canal客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">48.</span> <span class="toc-text">消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">48.1.</span> <span class="toc-text">消息可靠性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">48.2.</span> <span class="toc-text">生产者确认机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringAMQP%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">48.3.</span> <span class="toc-text">SpringAMQP实现生产者确认</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">49.</span> <span class="toc-text">消息持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%A1%AE%E8%AE%A4"><span class="toc-number">49.1.</span> <span class="toc-text">消费者确认</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">49.2.</span> <span class="toc-text">失败重试机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%B1%E8%B4%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">49.3.</span> <span class="toc-text">消费者失败消息处理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">49.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">50.</span> <span class="toc-text">死信交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">50.1.</span> <span class="toc-text">初识死信交换机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TTL"><span class="toc-number">50.2.</span> <span class="toc-text">TTL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">50.3.</span> <span class="toc-text">延迟队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-number">50.4.</span> <span class="toc-text">延迟队列插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringAMQP%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-number">50.5.</span> <span class="toc-text">SpringAMQP使用延迟队列插件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">51.</span> <span class="toc-text">惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">51.1.</span> <span class="toc-text">消息堆积问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97-1"><span class="toc-number">51.2.</span> <span class="toc-text">惰性队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ%E9%9B%86%E7%BE%A4"><span class="toc-number">52.</span> <span class="toc-text">MQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E7%B1%BB"><span class="toc-number">52.1.</span> <span class="toc-text">集群分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">52.2.</span> <span class="toc-text">普通集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">52.3.</span> <span class="toc-text">镜像集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97"><span class="toc-number">52.4.</span> <span class="toc-text">仲裁队列</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/24/git%E4%BD%BF%E7%94%A8/" title="git使用"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-4orw89_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git使用"/></a><div class="content"><a class="title" href="/2024/05/24/git%E4%BD%BF%E7%94%A8/" title="git使用">git使用</a><time datetime="2024-05-24T02:06:17.000Z" title="发表于 2024-05-24 10:06:17">2024-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GPT/" title="如何使用ChatGPT"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-28vm5y_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何使用ChatGPT"/></a><div class="content"><a class="title" href="/2024/05/04/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GPT/" title="如何使用ChatGPT">如何使用ChatGPT</a><time datetime="2024-05-04T06:19:35.000Z" title="发表于 2024-05-04 14:19:35">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/04/sql/" title="SQL"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-p2e71j_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SQL"/></a><div class="content"><a class="title" href="/2024/05/04/sql/" title="SQL">SQL</a><time datetime="2024-05-04T06:01:22.000Z" title="发表于 2024-05-04 14:01:22">2024-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/28/MongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/" title="MongoDB的使用"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-lm6wjl_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MongoDB的使用"/></a><div class="content"><a class="title" href="/2024/03/28/MongoDB%E7%9A%84%E4%BD%BF%E7%94%A8/" title="MongoDB的使用">MongoDB的使用</a><time datetime="2024-03-28T09:25:48.000Z" title="发表于 2024-03-28 17:25:48">2024-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/27/java%E4%BD%BF%E7%94%A8minio/" title="Java使用MinIO"><img src= "/img/5f47a60d5146459eb21b9f7bab476163ee81c664.gif@!web-article-pic.webp" data-lazy-src="/img/wallhaven-28vm5y_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java使用MinIO"/></a><div class="content"><a class="title" href="/2024/03/27/java%E4%BD%BF%E7%94%A8minio/" title="Java使用MinIO">Java使用MinIO</a><time datetime="2024-03-27T02:30:50.000Z" title="发表于 2024-03-27 10:30:50">2024-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 幻季</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'mEcl3ljE8Xejd5tGMxU8pycK-gzGzoHsz',
      appKey: '56r5hEb4WhpvTy6D2xTrOA1q',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'y8G9wcHsgfcBL4ARw'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>